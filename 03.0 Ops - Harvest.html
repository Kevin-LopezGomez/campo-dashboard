<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Harvest Productivity Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <style>
    :root {
      --bg: #020617;
      --bg-alt: #020617;
      --panel: #020617;
      --panel-soft: #020617;
      --card: #020617;
      --border: #1f2937;
      --border-subtle: #374151;
      --text: #e5e7eb;
      --sub: #9ca3af;
      --accent: #22c55e;
      --accent-soft: rgba(34, 197, 94, 0.15);
      --accent-strong: #4ade80;
      --danger: #ef4444;
      --danger-soft: rgba(239, 68, 68, 0.15);
      --muted: #6b7280;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #111827 0, #020617 45%, #000 100%);
      color: var(--text);
    }

    .page {
      min-height: 100vh;
      padding: 16px;
      display: flex;
      justify-content: center;
    }

    .container {
      width: 100%;
      max-width: 1320px;
      border-radius: 24px;
      padding: 20px 20px 16px;
      background:
        radial-gradient(circle at top right, rgba(34, 197, 94, 0.08), transparent 60%),
        radial-gradient(circle at bottom left, rgba(59, 130, 246, 0.09), transparent 55%),
        linear-gradient(135deg, rgba(15, 23, 42, 0.96), rgba(15, 23, 42, 0.98));
      border: 1px solid rgba(148, 163, 184, 0.35);
      box-shadow:
        0 24px 80px rgba(0, 0, 0, 0.8),
        0 0 0 1px rgba(15, 23, 42, 0.8);
      backdrop-filter: blur(20px);
    }

    .header {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
    }

    .title-block { flex: 1 1 200px; min-width: 0; }

    .title {
      display: flex;
      align-items: center;
      gap: 10px;
      margin: 0 0 4px;
      font-size: 1.3rem;
      letter-spacing: 0.02em;
    }

    .title-pill {
      width: 26px;
      height: 26px;
      border-radius: 999px;
      background: radial-gradient(circle at 30% 20%, #34d399, #22c55e 55%, #16a34a 100%);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 0 0 2px rgba(15, 23, 42, 0.9), 0 12px 30px rgba(16, 185, 129, 0.6);
    }

    .title-pill span {
      font-size: 15px;
      font-weight: 700;
      color: #022c22;
    }

    .title-text {
      font-weight: 620;
      display: flex;
      align-items: baseline;
      gap: 8px;
    }

    .title-sub {
      font-size: 0.8rem;
      color: var(--sub);
      text-transform: uppercase;
      letter-spacing: 0.18em;
    }

    .subtitle {
      margin: 0;
      font-size: 0.85rem;
      color: var(--muted);
    }

    .header-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border-radius: 999px;
      padding: 4px 9px;
      font-size: 0.72rem;
      border: 1px solid rgba(148, 163, 184, 0.5);
      color: var(--sub);
      background: radial-gradient(circle at top left, rgba(148, 163, 184, 0.18), transparent 55%);
    }

    .chip-dot {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: var(--accent);
      box-shadow: 0 0 0 3px rgba(34, 197, 94, 0.35);
    }

    .chip-warn-dot {
      background: #facc15;
      box-shadow: 0 0 0 3px rgba(250, 204, 21, 0.4);
    }

    .chip-danger-dot {
      background: var(--danger);
      box-shadow: 0 0 0 3px rgba(248, 113, 113, 0.4);
    }

    .kpi-grid {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 10px;
      margin-bottom: 16px;
      margin-top: 10px;
    }

    @media (max-width: 960px) {
      .kpi-grid { grid-template-columns: repeat(2, minmax(0, 1fr)); }
    }

    .kpi-card {
      position: relative;
      border-radius: 16px;
      padding: 10px 12px 11px;
      background: radial-gradient(circle at top left, rgba(31, 41, 55, 0.85), rgba(15, 23, 42, 0.98));
      border: 1px solid rgba(51, 65, 85, 0.9);
      box-shadow:
        0 14px 30px rgba(0, 0, 0, 0.9),
        0 0 0 1px rgba(15, 23, 42, 0.9);
      overflow: hidden;
    }

    .kpi-label {
      font-size: 0.74rem;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      color: var(--sub);
      margin-bottom: 4px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    .kpi-value {
      font-size: 1.15rem;
      font-weight: 650;
      display: flex;
      align-items: baseline;
      gap: 4px;
    }

    .kpi-unit {
      font-size: 0.72rem;
      color: var(--muted);
      text-transform: uppercase;
    }

    .kpi-trend {
      margin-top: 2px;
      font-size: 0.7rem;
      color: var(--accent-strong);
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .kpi-trend.muted { color: var(--muted); }

    .kpi-glow {
      position: absolute;
      inset: 0;
      opacity: 0.18;
      background:
        radial-gradient(circle at 15% 0, rgba(34, 197, 94, 0.4), transparent 55%),
        radial-gradient(circle at 100% 100%, rgba(59, 130, 246, 0.4), transparent 60%);
      pointer-events: none;
      mix-blend-mode: screen;
    }

    .panel {
      border-radius: 18px;
      padding: 12px 12px 10px;
      background: radial-gradient(circle at top left, rgba(15, 23, 42, 0.97), rgba(15, 23, 42, 0.99));
      border: 1px solid rgba(55, 65, 81, 0.9);
      box-shadow:
        0 18px 40px rgba(0, 0, 0, 0.9),
        0 0 0 1px rgba(15, 23, 42, 0.9);
      backdrop-filter: blur(14px);
      min-height: 0;
      display: flex;
      flex-direction: column;
    }

    .panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 6px;
    }

    .panel-title {
      font-size: 0.82rem;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--sub);
      display: flex;
      align-items: center;
      gap: 7px;
    }

    .panel-title-dot {
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: var(--accent);
      box-shadow: 0 0 0 3px rgba(34, 197, 94, 0.45);
    }

    .panel-subtitle {
      font-size: 0.75rem;
      color: var(--muted);
    }

    .panel-header-right {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 0.72rem;
      color: var(--sub);
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .badge-soft {
      border-radius: 999px;
      padding: 3px 8px;
      border: 1px solid rgba(148, 163, 184, 0.45);
      background: radial-gradient(circle at top left, rgba(30, 64, 175, 0.55), rgba(15, 23, 42, 0.95));
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 0.72rem;
    }

    .badge-soft span {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: rgba(226, 232, 240, 0.95);
    }

    .badge-dot {
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: #38bdf8;
      box-shadow: 0 0 0 3px rgba(56, 189, 248, 0.48);
    }

    .view-toggle {
      display: inline-flex;
      align-items: center;
      border-radius: 999px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      background: rgba(15, 23, 42, 0.95);
      padding: 1px;
      font-size: 0.7rem;
    }

    .view-toggle-btn {
      border: none;
      background: transparent;
      color: var(--sub);
      padding: 3px 8px;
      border-radius: 999px;
      cursor: pointer;
      font-size: 0.7rem;
      font-family: inherit;
    }

    .view-toggle-btn.active {
      background: rgba(34, 197, 94, 0.18);
      color: #bbf7d0;
    }

    .trend-toggle {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-size: 0.7rem;
      color: var(--sub);
      padding: 3px 7px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(55, 65, 81, 0.9);
    }

    .trend-toggle input { margin: 0; }

    .layout-main {
      display: grid;
      grid-template-columns: minmax(0, 2.2fr) minmax(0, 2.2fr);
      gap: 16px;
      align-items: stretch;
    }

    @media (max-width: 960px) {
      .layout-main { grid-template-columns: minmax(0, 1fr); }
    }

    .chart-wrapper {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 4px;
      flex: 1 1 auto;
    }

    .chart-row { position: relative; width: 100%; }
    .chart-canvas-main { width: 100%; height: 230px; }
    .chart-canvas-secondary { width: 100%; height: 200px; }

    @media (max-width: 960px) {
      .chart-canvas-main { height: 210px; }
      .chart-canvas-secondary { height: 180px; }
    }

    .footer-note {
      margin-top: 8px;
      font-size: 0.7rem;
      color: var(--muted);
      display: flex;
      justify-content: flex-end;
      gap: 12px;
      flex-wrap: wrap;
    }

    .footer-note span {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .legend-box {
      width: 10px;
      height: 10px;
      border-radius: 2px;
      border: 1px solid rgba(148, 163, 184, 0.8);
    }

    .legend-box.boards { background: rgba(59, 130, 246, 0.6); }
    .legend-box.bph { background: rgba(34, 197, 94, 0.7); }

    .table-wrapper {
      margin-top: 4px;
      border-radius: 14px;
      border: 1px solid rgba(55, 65, 81, 0.95);
      background:
        linear-gradient(135deg, rgba(17, 24, 39, 0.96), rgba(15, 23, 42, 0.99)),
        radial-gradient(circle at top left, rgba(51, 65, 85, 0.65), rgba(15, 23, 42, 0.96));
      overflow: hidden;
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
    }

    .table-scroll {
      max-height: 430px;
      overflow: auto;
      scrollbar-width: thin;
      scrollbar-color: #4b5563 rgba(15, 23, 42, 0.2);
      flex: 1 1 auto;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.78rem;
      min-width: 980px;
    }

    thead {
      position: sticky;
      top: 0;
      z-index: 2;
      background:
        linear-gradient(to bottom, #020617, #020617),
        radial-gradient(circle at top left, rgba(55, 65, 81, 0.5), rgba(15, 23, 42, 0.95));
      box-shadow: 0 1px 0 rgba(31, 41, 55, 0.9);
    }

    th, td {
      text-align: right;
      padding: 6px 10px;
      border-bottom: 1px solid rgba(31, 41, 55, 0.85);
      white-space: nowrap;
    }

    th:first-child, td:first-child {
      text-align: left;
      padding-left: 14px;
    }

    th {
      font-size: 0.72rem;
      text-transform: uppercase;
      letter-spacing: 0.15em;
      color: var(--sub);
    }

    tbody tr:nth-child(odd) td { background: rgba(15, 23, 42, 0.85); }
    tbody tr:nth-child(even) td { background: rgba(17, 24, 39, 0.92); }

    tfoot td {
      background:
        radial-gradient(circle at 0 0, rgba(34, 197, 94, 0.12), rgba(15, 23, 42, 0.98));
      font-weight: 600;
      border-top: 1px solid rgba(55, 65, 81, 0.95);
      border-bottom: none;
    }

    .cell-pill {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 3px 7px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.95);
      border: 1px solid rgba(55, 65, 81, 0.9);
      font-variant-numeric: tabular-nums;
    }

    .cell-percent-good {
      color: #bbf7d0;
      border-color: rgba(74, 222, 128, 0.7);
      background: radial-gradient(circle at 0 0, rgba(22, 163, 74, 0.25), rgba(15, 23, 42, 0.96));
    }

    .cell-percent-warn {
      color: #fed7aa;
      border-color: rgba(249, 115, 22, 0.8);
      background: radial-gradient(circle at 0 0, rgba(251, 146, 60, 0.25), rgba(15, 23, 42, 0.96));
    }

    .cell-percent-low {
      color: #fecaca;
      border-color: rgba(248, 113, 113, 0.8);
      background: radial-gradient(circle at 0 0, rgba(248, 113, 113, 0.25), rgba(15, 23, 42, 0.96));
    }

    .hidden { display: none; }
    .hint-empty { font-size: 0.75rem; color: var(--muted); margin-top: 6px; white-space: pre-wrap; }

    .debug {
      margin-top: 8px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      background: rgba(2,6,23,.35);
      font-size: .74rem;
      color: var(--sub);
      display:none;
      white-space: pre-wrap;
    }
  </style>
</head>

<body>
  <div class="page">
    <div class="container">
      <header class="header">
        <div class="title-block">
          <div class="title">
            <div class="title-pill"><span>H</span></div>
            <div class="title-text">
              <span>Harvest Productivity Dashboard</span>
              <span class="title-sub">LIVE FROM DATA INPUT</span>
            </div>
          </div>
          <p class="subtitle">
            Cut-level harvest output, yield, and waste. KPIs are computed at the DAILY level using the daily span:
            <b>earliest “Harvest Start” → latest “Harvest Finish”</b> (per date).
          </p>
        </div>

        <div class="header-tags">
          <div class="chip"><span class="chip-dot"></span><span id="chip-high-text">–</span></div>
          <div class="chip"><span class="chip-warn-dot"></span><span id="chip-mid-text">–</span></div>
          <div class="chip"><span class="chip-danger-dot"></span><span id="chip-low-text">–</span></div>
        </div>
      </header>

      <section class="kpi-grid">
        <article class="kpi-card">
          <div class="kpi-glow"></div>
          <div class="kpi-label"><span>Total boards harvested</span><span id="kpi-days" class="kpi-unit"></span></div>
          <div class="kpi-value"><span id="kpi-total-boards">–</span></div>
          <div class="kpi-trend muted"><span>Across all recorded harvest days</span></div>
        </article>

        <article class="kpi-card">
          <div class="kpi-glow"></div>
          <div class="kpi-label"><span>Average boards / hour</span></div>
          <div class="kpi-value"><span id="kpi-avg-bph">–</span><span class="kpi-unit">BPH</span></div>
          <div class="kpi-trend"><span id="kpi-bph-note">Top day: –</span></div>
        </article>

        <article class="kpi-card">
          <div class="kpi-glow"></div>
          <div class="kpi-label"><span>Average harvest duration</span></div>
          <div class="kpi-value"><span id="kpi-avg-hours">–</span><span class="kpi-unit">Hours</span></div>
          <div class="kpi-trend muted"><span id="kpi-hours-note">–</span></div>
        </article>

        <article class="kpi-card">
          <div class="kpi-glow"></div>
          <div class="kpi-label"><span>Total weight harvested</span></div>
          <div class="kpi-value"><span id="kpi-total-cut">–</span><span class="kpi-unit">LBS</span></div>
          <div class="kpi-trend muted"><span id="kpi-weight-note">–</span></div>
        </article>
      </section>

      <section class="layout-main">
        <section class="panel">
          <div class="panel-header">
            <div>
              <div class="panel-title"><span class="panel-title-dot"></span><span>Performance over time</span></div>
              <div class="panel-subtitle">
                Top: Boards harvested · Middle: Cut weight & “with waste” target · Bottom: Boards per hour. View by cut, day, or harvest week.
              </div>
            </div>
            <div class="panel-header-right">
              <div class="badge-soft"><span class="badge-dot"></span><span>Live from Data Input</span></div>
              <div class="view-toggle">
                <button id="view-by-cut" class="view-toggle-btn" type="button">By cut</button>
                <button id="view-by-date" class="view-toggle-btn active" type="button">By day</button>
                <button id="view-by-week" class="view-toggle-btn" type="button">By harvest week</button>
              </div>
              <label class="trend-toggle">
                <input type="checkbox" id="trend-toggle-input" />
                <span>Trend line</span>
              </label>
            </div>
          </div>

          <div class="chart-wrapper">
            <div class="chart-row"><canvas id="chart-boards" class="chart-canvas-main"></canvas></div>
            <div class="chart-row"><canvas id="chart-weight" class="chart-canvas-main"></canvas></div>
            <div class="chart-row"><canvas id="chart-bph" class="chart-canvas-secondary"></canvas></div>
          </div>

          <div class="footer-note">
            <span><span class="legend-box boards"></span> Top: Boards harvested</span>
            <span><span class="legend-box boards"></span> Middle: Cut lbs + With-waste target</span>
            <span><span class="legend-box bph"></span> Bottom: Boards/hour</span>
          </div>
        </section>

        <section class="panel">
          <div class="panel-header">
            <div>
              <div class="panel-title"><span class="panel-title-dot"></span><span id="harvest-table-title">Cut-level harvest log</span></div>
              <div class="panel-subtitle" id="harvest-table-subtitle">
                Each row is a harvest cut loaded from Master Grow. Switch view to see daily or weekly summaries.
              </div>
            </div>
            <div class="panel-header-right">
              <span id="harvest-table-hint">Scroll to see all cuts</span>
              <div class="view-toggle">
                <button id="table-view-cut" class="view-toggle-btn active" type="button">By cut</button>
                <button id="table-view-daily" class="view-toggle-btn" type="button">By day</button>
                <button id="table-view-weekly" class="view-toggle-btn" type="button">By week</button>
              </div>
            </div>
          </div>

          <div class="table-wrapper">
            <div class="table-scroll">
              <table id="harvest-table">
                <thead>
                  <tr>
                    <th>Harvest Date / Week</th>
                    <th>Harvest Week</th>
                    <th># Boards Harvested</th>
                    <th>Hours (Span)</th>
                    <th>Cut Lbs</th>
                    <th>Waste Weight</th>
                    <th>With Waste</th>
                    <th>Lbs / Board</th>
                    <th>Boards / Hour</th>
                    <th>% Potential</th>
                  </tr>
                </thead>
                <tbody id="harvest-tbody-cut"></tbody>
                <tbody id="harvest-tbody-daily" class="hidden"></tbody>
                <tbody id="harvest-tbody-weekly" class="hidden"></tbody>
                <tfoot>
                  <tr>
                    <td>Grand Total</td><td>–</td><td>0</td><td>0.0</td><td>0</td><td>0</td><td>0</td><td>0.0</td><td>0.0</td><td>0%</td>
                  </tr>
                </tfoot>
              </table>
            </div>
          </div>

          <div id="empty-hint" class="hint-empty"></div>
          <div id="debug" class="debug"></div>
        </section>
      </section>
    </div>
  </div>

  <script>
    // =========================================================
    // STORAGE CONTRACT
    // =========================================================
    const MASTER_GROW_KEY = "campo_master_grow_v1";
    const MASTER_GROW_PING_KEY = "campo_master_grow_push_ping_v1";

    // IMPORTANT: We accept multiple possible sheet names (bulletproof),
    // but prefer "Master Grow" as the canonical name.
    const SHEET_CANDIDATES = [
      "Master Grow",
      "master grow",
      "MASTER GROW",
      "Grow",
      "grow",
      "MG",
      "mg"
    ];

    // Parent/index message types
    const MSG_GROW = "MASTER_GROW_UPDATED";

    // BroadcastChannel (same-origin only; harmless if unsupported)
    const BC_NAME = "campo_master_bus_v1";
    const bc = ("BroadcastChannel" in window) ? new BroadcastChannel(BC_NAME) : null;

    // =========================================================
    // CANONICAL (meaning) headers we use internally
    // =========================================================
    const H = Object.freeze({
      DATE: "Harvest Date",
      WEEK: "Harvest Week",
      START: "Harvest Start",
      FINISH: "Harvest Finish",
      WORKERS: "Harvest # of Workers",
      BOARDS: "# of Boards Harvested",
      CUT_LBS: "Peso de La Lechuga Cortada",
      WASTE_LBS: "Total Harvest Waste Weight",
      WITH_WASTE_LBS: "Peso de La Lechuga con Waste"
    });

    // =========================================================
    // HEADER ALIASES (tolerant like Seeding)
    // Add anything you ever see here.
    // =========================================================
    function normHeader(s){
      return String(s ?? "").replace(/\s+/g, " ").trim().toLowerCase();
    }

    const HEADER_ALIASES = new Map([
      // Date
      ["harvest date", H.DATE],
      ["date", H.DATE],
      ["fecha de harvest", H.DATE],
      ["fecha de cosecha", H.DATE],
      ["cosecha date", H.DATE],

      // Week
      ["harvest week", H.WEEK],
      ["week", H.WEEK],
      ["cosecha week", H.WEEK],
      ["semana", H.WEEK],
      ["semana de cosecha", H.WEEK],

      // Start/Finish
      ["harvest start", H.START],
      ["start", H.START],
      ["inicio", H.START],
      ["inicio harvest", H.START],
      ["inicio de cosecha", H.START],

      ["harvest finish", H.FINISH],
      ["finish", H.FINISH],
      ["final", H.FINISH],
      ["fin", H.FINISH],
      ["final harvest", H.FINISH],
      ["final de cosecha", H.FINISH],

      // Workers
      ["harvest # of workers", H.WORKERS],
      ["harvest workers", H.WORKERS],
      ["# of workers", H.WORKERS],
      ["workers", H.WORKERS],
      ["trabajadores", H.WORKERS],

      // Boards
      ["# of boards harvested", H.BOARDS],
      ["boards harvested", H.BOARDS],
      ["boards", H.BOARDS],
      ["# boards harvested", H.BOARDS],

      // Cut lbs (common variants)
      ["peso de la lechuga cortada", H.CUT_LBS],
      ["peso de la lechuga  cortada", H.CUT_LBS],
      ["peso lechuga cortada", H.CUT_LBS],
      ["cut lbs", H.CUT_LBS],
      ["cut weight", H.CUT_LBS],

      // Waste
      ["total harvest waste weight", H.WASTE_LBS],
      ["waste weight", H.WASTE_LBS],
      ["waste", H.WASTE_LBS],
      ["desperdicio", H.WASTE_LBS],
      ["peso waste", H.WASTE_LBS],

      // With waste
      ["peso de la lechuga con waste", H.WITH_WASTE_LBS],
      ["with waste", H.WITH_WASTE_LBS],
      ["con waste", H.WITH_WASTE_LBS],
      ["total with waste", H.WITH_WASTE_LBS]
    ]);

    function canonicalizeHeaders(headersRaw){
      const canonHeaders = [];
      const canonIndexByName = new Map();
      headersRaw.forEach((h, idx) => {
        const raw = String(h ?? "");
        const key = normHeader(raw);
        const canon = HEADER_ALIASES.get(key) || raw.trim();
        canonHeaders[idx] = canon;
        if (canon && !canonIndexByName.has(canon)) canonIndexByName.set(canon, idx);
      });
      return { canonHeaders, canonIndexByName };
    }

    // =========================================================
    // STATE
    // =========================================================
    let boardsChart = null;
    let weightChart = null;
    let bphChart = null;

    let chartMode = "date";   // "cut" | "date" | "week"
    let tableMode = "cut";    // "cut" | "daily" | "weekly"
    let showTrendLine = false;

    let CUTS = [];
    let DAILY = [];
    let WEEKLY = [];

    // =========================================================
    // HELPERS
    // =========================================================
    function setEmpty(msg) {
      const el = document.getElementById("empty-hint");
      if (el) el.textContent = msg || "";
    }
    function setDebug(msg){
      const el = document.getElementById("debug");
      if (!el) return;
      if (!msg) { el.style.display="none"; el.textContent=""; return; }
      el.style.display="block";
      el.textContent = msg;
    }

    function parseNumber(v) {
      if (v === null || v === undefined) return 0;
      if (typeof v === "number" && Number.isFinite(v)) return v;
      const s = String(v).trim();
      if (!s) return 0;
      if (s.toUpperCase().includes("#VALUE")) return 0;
      const cleaned = s.replace(/,/g, "");
      const n = parseFloat(cleaned);
      return Number.isFinite(n) ? n : 0;
    }

    // --- Robust month-name date parsing (CSV format like: "Friday, December 19, 2025")
    function parseMonthNameDate(s) {
      const raw = String(s || "").trim();
      if (!raw) return null;

      const parts = raw.split(",");
      const cleaned = (parts.length >= 2) ? parts.slice(1).join(",").trim() : raw;

      const m = cleaned.match(/^([A-Za-z]+)\s+(\d{1,2}),\s*(\d{4})$/);
      if (!m) return null;

      const monthName = m[1].toLowerCase();
      const day = parseInt(m[2], 10);
      const year = parseInt(m[3], 10);

      const months = {
        january:0,february:1,march:2,april:3,may:4,june:5,
        july:6,august:7,september:8,october:9,november:10,december:11
      };
      if (!(monthName in months)) return null;

      // Build in UTC to avoid timezone day-shifts
      const d = new Date(Date.UTC(year, months[monthName], day));
      return isNaN(d.getTime()) ? null : d;
    }

    function normalizeToUTCMidnight(d) {
      return new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate()));
    }

    // Handles: Date obj, MM/DD/YYYY, ISO, long-form, Excel serial number, Month-name (with optional weekday)
    function parseAnyDate(v){
      if (v === null || v === undefined) return null;
      if (v instanceof Date && !isNaN(v.getTime())) return v;

      // Excel serial number (number)
      if (typeof v === "number" && Number.isFinite(v) && v > 20000 && v < 60000) {
        const excelEpoch = new Date(Date.UTC(1899, 11, 30));
        const d = new Date(excelEpoch.getTime() + v * 86400000);
        return isNaN(d.getTime()) ? null : d;
      }

      const s0 = String(v).trim();
      if (!s0) return null;

      // common "no date" tokens
      const s0n = s0.toLowerCase();
      if (s0n === "(no date)" || s0n === "no date" || s0n === "n/a" || s0n === "na" || s0n === "null" || s0n === "undefined") return null;

      // Month-name (robust for CSV)
      const monthNameParsed = parseMonthNameDate(s0);
      if (monthNameParsed) return monthNameParsed;

      // Excel serial number (string)
      const n = Number(s0);
      if (Number.isFinite(n) && n > 20000 && n < 60000) {
        const excelEpoch = new Date(Date.UTC(1899, 11, 30));
        const d = new Date(excelEpoch.getTime() + n * 86400000);
        return isNaN(d.getTime()) ? null : d;
      }

      // Strip weekday prefix: "Wednesday, October 1, 2025"
      let s = s0;
      const parts = s.split(",");
      if (parts.length >= 2 && /[a-z]/i.test(parts[0])) s = parts.slice(1).join(",").trim();

      // ISO
      if (/^\d{4}-\d{2}-\d{2}/.test(s)) {
        const d = new Date(s);
        return isNaN(d.getTime()) ? null : d;
      }

      // US MM/DD/YYYY
      if (/^\d{1,2}\/\d{1,2}\/\d{2,4}$/.test(s)) {
        const [mm, dd, yy] = s.split("/").map(Number);
        const yyyy = yy < 100 ? 2000 + yy : yy;
        const d = new Date(Date.UTC(yyyy, mm - 1, dd));
        return isNaN(d.getTime()) ? null : d;
      }

      // Fallback (least reliable; but last resort)
      const d = new Date(s);
      return isNaN(d.getTime()) ? null : d;
    }

    function formatDateMMDDYYYY(date) {
      // IMPORTANT: UTC getters to avoid timezone day-shifts
      const mm = String(date.getUTCMonth() + 1).padStart(2, "0");
      const dd = String(date.getUTCDate()).padStart(2, "0");
      const yyyy = date.getUTCFullYear();
      return `${mm}/${dd}/${yyyy}`;
    }

    // Time parsing: supports "HH:MM", "HH:MM AM/PM", decimal hours (e.g. 6.5), and Excel time fractions (0.5)
    function parseTimeToMinutes(v) {
      if (v === null || v === undefined) return NaN;

      // Excel time fraction (0..1)
      if (typeof v === "number" && Number.isFinite(v) && v >= 0 && v < 1) {
        return Math.round(v * 24 * 60);
      }

      // Decimal hours (e.g. 6.5)
      if (typeof v === "number" && Number.isFinite(v) && v >= 1 && v <= 24) {
        return Math.round(v * 60);
      }

      const str = String(v ?? "").trim();
      if (!str) return NaN;

      // If it's numeric string
      const asNum = Number(str);
      if (Number.isFinite(asNum)) {
        if (asNum >= 0 && asNum < 1) return Math.round(asNum * 24 * 60);
        if (asNum >= 1 && asNum <= 24) return Math.round(asNum * 60);
      }

      const m = str.match(/^(\d{1,2}):(\d{2})(?:\s*([APap][Mm]))?$/);
      if (!m) return NaN;
      let hh = parseInt(m[1], 10);
      const mm = parseInt(m[2], 10);
      const ap = m[3] ? m[3].toUpperCase() : "";
      if (ap) {
        if (hh === 12) hh = 0;
        if (ap === "PM") hh += 12;
      }
      return hh * 60 + mm;
    }

    function spanHoursFromMinMax(minStartMin, maxFinishMin) {
      if (!Number.isFinite(minStartMin) || !Number.isFinite(maxFinishMin)) return 0;
      let diff = maxFinishMin - minStartMin;
      if (diff < 0) diff += 24 * 60;
      return diff / 60;
    }

    function computeTrendLine(values) {
      const n = values.length;
      if (n < 2) return [];
      let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;
      for (let i = 0; i < n; i++) {
        const x = i + 1;
        const y = Number(values[i]) || 0;
        sumX += x; sumY += y; sumXY += x * y; sumXX += x * x;
      }
      const denom = n * sumXX - sumX * sumX;
      if (denom === 0) return Array(n).fill(values[0] || 0);
      const slope = (n * sumXY - sumX * sumY) / denom;
      const intercept = (sumY - slope * sumX) / n;
      return Array.from({ length: n }, (_, i) => slope * (i + 1) + intercept);
    }

    // =========================================================
    // LOAD PAYLOAD + FIND SHEET (bulletproof)
    // =========================================================
    function loadMasterGrowPayload() {
      const raw = (localStorage.getItem(MASTER_GROW_KEY) || "").trim();
      if (!raw) return null;
      try { return JSON.parse(raw); } catch { return null; }
    }

    function pickSheet(payload){
      const sheets = payload?.sheets || {};
      if (!sheets || typeof sheets !== "object") return null;

      // Exact candidate match
      for (const name of SHEET_CANDIDATES) {
        if (name in sheets) return { name, sheet: sheets[name] };
      }

      // Case-insensitive / includes match
      const keys = Object.keys(sheets);
      const normKeys = keys.map(k => ({ k, nk: String(k).trim().toLowerCase() }));
      for (const want of SHEET_CANDIDATES.map(s => String(s).trim().toLowerCase())) {
        const hit = normKeys.find(x => x.nk === want) || normKeys.find(x => x.nk.includes(want));
        if (hit) return { name: hit.k, sheet: sheets[hit.k] };
      }

      // Fallback: first sheet
      if (keys.length) return { name: keys[0], sheet: sheets[keys[0]] };
      return null;
    }

    function sheetToRowObjects(sheetObj) {
      const headersRaw = Array.isArray(sheetObj?.headers) ? sheetObj.headers : [];
      const rows = Array.isArray(sheetObj?.rows) ? sheetObj.rows : [];

      const { canonHeaders } = canonicalizeHeaders(headersRaw);

      const out = [];
      for (const r of rows) {
        if (!Array.isArray(r)) continue;
        const obj = {};
        for (let i = 0; i < canonHeaders.length; i++) {
          const key = String(canonHeaders[i] ?? "").trim();
          if (!key) continue;
          obj[key] = (i < r.length) ? r[i] : "";
        }
        out.push(obj);
      }
      return { rows: out, canonHeaders };
    }

    function getCutLbs(row) {
      // We canonicalize to H.CUT_LBS, but we also try common raw variants just in case.
      const v = parseNumber(row[H.CUT_LBS]);
      if (v) return v;

      const fallbacks = [
        "Peso de la Lechuga Cortada",
        "PESO DE LA LECHUGA CORTADA",
        "peso de la lechuga cortada"
      ];
      for (const h of fallbacks) {
        if (h in row) {
          const n = parseNumber(row[h]);
          if (n) return n;
        }
      }
      return 0;
    }

    function getWithWasteLbs(row, cut, waste) {
      const v = parseNumber(row[H.WITH_WASTE_LBS]);
      if (v > 0) return v;
      return (cut || 0) + (waste || 0);
    }

    // =========================================================
    // BUILD MODELS (CUTS / DAILY / WEEKLY)
    // =========================================================
    function buildModels() {
      const payload = loadMasterGrowPayload();
      if (!payload) {
        CUTS = []; DAILY = []; WEEKLY = [];
        setEmpty("No Master Grow payload in localStorage.\n\nFix:\n- Open Data Input\n- Upload Master Grow\n- Confirm it saves to campo_master_grow_v1");
        setDebug("");
        return;
      }

      const picked = pickSheet(payload);
      if (!picked || !picked.sheet) {
        CUTS = []; DAILY = []; WEEKLY = [];
        setEmpty("Master Grow payload loaded, but no sheets were found.");
        setDebug("Sheets keys:\n- " + Object.keys(payload.sheets || {}).join("\n- "));
        return;
      }

      const { rows, canonHeaders } = sheetToRowObjects(picked.sheet);

      if (!rows.length) {
        CUTS = []; DAILY = []; WEEKLY = [];
        setEmpty(`Sheet "${picked.name}" loaded, but it has 0 rows.`);
        setDebug("Canonical headers (first 80):\n- " + canonHeaders.slice(0,80).filter(Boolean).join("\n- "));
        return;
      }

      // Required canonical headers (tolerant input via alias mapping)
      const headerSet = new Set(canonHeaders.map(h => String(h || "").trim()).filter(Boolean));
      const required = [H.DATE, H.WEEK, H.START, H.FINISH, H.BOARDS];
      const missing = required.filter(h => !headerSet.has(h));

      // We do NOT hard-fail; we degrade gracefully and explain what is missing.
      const softWarnings = [];
      if (missing.length) softWarnings.push("Missing required headers:\n- " + missing.join("\n- "));
      if (!headerSet.has(H.CUT_LBS)) softWarnings.push("Missing cut-lbs header (will show 0 cut lbs unless alias exists).");
      if (!headerSet.has(H.WASTE_LBS)) softWarnings.push("Missing waste-lbs header (waste will be 0 unless alias exists).");

      setEmpty(softWarnings.length ? ("Master Grow loaded with warnings.\n\n" + softWarnings.join("\n\n")) : "");
      setDebug(
        `Using sheet: ${picked.name}\n` +
        `Rows: ${rows.length.toLocaleString()}\n` +
        `Sheets available: ${(Object.keys(payload.sheets||{}).length)}\n\n` +
        `Canonical headers (first 80):\n- ${canonHeaders.slice(0,80).filter(Boolean).join("\n- ")}`
      );

      // CUTS
      const cuts = [];
      let droppedBlank = 0;
      let droppedNoDate = 0;

      for (const r of rows) {
        if (!r || typeof r !== "object") continue;

        // --- FIX: normalize dates to UTC-midnight and format using UTC getters
        const rawDate = parseAnyDate(r[H.DATE]);
        if (!rawDate) { droppedNoDate++; continue; }
        const dateObj = normalizeToUTCMidnight(rawDate);
        const date = formatDateMMDDYYYY(dateObj);

        const week = String(r[H.WEEK] ?? "").trim();

        const startMin = parseTimeToMinutes(r[H.START]);
        const finishMin = parseTimeToMinutes(r[H.FINISH]);

        const boards = parseNumber(r[H.BOARDS]);
        const cut = getCutLbs(r);
        const waste = parseNumber(r[H.WASTE_LBS]);
        const workers = parseNumber(r[H.WORKERS]);

        const allBlank =
          !week &&
          !String(r[H.START] ?? "").trim() && !String(r[H.FINISH] ?? "").trim() &&
          boards === 0 && cut === 0 && waste === 0 && workers === 0;

        if (allBlank) { droppedBlank++; continue; }

        const spanH = spanHoursFromMinMax(startMin, finishMin);
        const withWaste = getWithWasteLbs(r, cut, waste);

        const lbsPerBoard = boards > 0 ? (cut / boards) : 0;
        const bph = spanH > 0 ? (boards / spanH) : 0;
        const potential = withWaste > 0 ? (cut / withWaste) * 100 : 0;

        cuts.push({
          dateObj,
          date,
          week,
          boards,
          cut,
          waste,
          withWaste,
          lbsPerBoard,
          bph,
          potential,
          startMin,
          finishMin,
          workers
        });
      }

      // Sort cuts by date then by start time
      cuts.sort((a,b) => (a.dateObj - b.dateObj) || ((a.startMin||0)-(b.startMin||0)));

      // DAILY: aggregate by date; span uses earliest start -> latest finish for that day.
      const dayMap = new Map();
      for (const c of cuts) {
        const key = c.date;
        if (!dayMap.has(key)) {
          dayMap.set(key, {
            date: key,
            dateObj: c.dateObj,
            weekGuess: c.week || "",
            minStartMin: Number.isFinite(c.startMin) ? c.startMin : NaN,
            maxFinishMin: Number.isFinite(c.finishMin) ? c.finishMin : NaN,
            boards: 0,
            cut: 0,
            waste: 0,
            withWaste: 0,
            workersSum: 0,
            workersCount: 0
          });
        }
        const d = dayMap.get(key);

        if (Number.isFinite(c.startMin)) d.minStartMin = Number.isFinite(d.minStartMin) ? Math.min(d.minStartMin, c.startMin) : c.startMin;
        if (Number.isFinite(c.finishMin)) d.maxFinishMin = Number.isFinite(d.maxFinishMin) ? Math.max(d.maxFinishMin, c.finishMin) : c.finishMin;

        d.boards += c.boards;
        d.cut += c.cut;
        d.waste += c.waste;
        d.withWaste += c.withWaste;

        if (c.workers > 0) { d.workersSum += c.workers; d.workersCount += 1; }
        if (!d.weekGuess && c.week) d.weekGuess = c.week;
      }

      const daily = Array.from(dayMap.values())
        .sort((a,b) => a.dateObj - b.dateObj) // chronological for charts
        .map(d => {
          const spanH = spanHoursFromMinMax(d.minStartMin, d.maxFinishMin);
          const bph = spanH > 0 ? (d.boards / spanH) : 0;
          const lbsPerBoard = d.boards > 0 ? (d.cut / d.boards) : 0;
          const potential = d.withWaste > 0 ? (d.cut / d.withWaste) * 100 : 0;
          const avgWorkers = d.workersCount > 0 ? (d.workersSum / d.workersCount) : 0;
          return {
            date: d.date,
            dateObj: d.dateObj,
            week: d.weekGuess || "",
            spanH,
            boards: d.boards,
            cut: d.cut,
            waste: d.waste,
            withWaste: d.withWaste,
            bph,
            lbsPerBoard,
            potential,
            avgWorkers
          };
        });

      // WEEKLY: aggregate from daily by numeric week where possible; otherwise lexicographic.
      const wkMap = new Map();
      for (const d of daily) {
        const wkStr = String(d.week ?? "").trim();
        if (!wkStr) continue;
        const key = wkStr;
        if (!wkMap.has(key)) wkMap.set(key, { week: wkStr, spanH: 0, boards: 0, cut: 0, waste: 0, withWaste: 0 });
        const w = wkMap.get(key);
        w.spanH += d.spanH;
        w.boards += d.boards;
        w.cut += d.cut;
        w.waste += d.waste;
        w.withWaste += d.withWaste;
      }

      const weekOrderValue = (weekStr) => {
        const n = parseFloat(weekStr);
        if (isNaN(n)) return null;
        return n <= 4 ? n + 100 : n;
      };

      const weekly = Array.from(wkMap.values()).sort((a,b) => {
        const aw = weekOrderValue(a.week);
        const bw = weekOrderValue(b.week);
        if (aw === null || bw === null) return String(a.week).localeCompare(String(b.week));
        return aw - bw;
      }).map(w => {
        const bph = w.spanH > 0 ? (w.boards / w.spanH) : 0;
        const lbsPerBoard = w.boards > 0 ? (w.cut / w.boards) : 0;
        const potential = w.withWaste > 0 ? (w.cut / w.withWaste) * 100 : 0;
        return { ...w, bph, lbsPerBoard, potential };
      });

      CUTS = cuts;
      DAILY = daily;
      WEEKLY = weekly;

      // If we built nothing, provide diagnostics
      if (!CUTS.length) {
        setEmpty(
          "No harvest cuts were built.\n\nDiagnostics:\n" +
          `- Dropped blank rows: ${droppedBlank}\n` +
          `- Dropped rows w/ unparseable date: ${droppedNoDate}\n\n` +
          "Fix:\n- Ensure Harvest Date is present (MM/DD/YYYY, ISO, long-form, Month-name, or Excel serial)\n- Ensure headers match (or add alias in HEADER_ALIASES)"
        );
      }
    }

    // =========================================================
    // KPIs
    // =========================================================
    function renderKPIs() {
      const fmtInt = (n) => n.toLocaleString(undefined, { maximumFractionDigits: 0 });
      const fmt1 = (n) => n.toLocaleString(undefined, { maximumFractionDigits: 1 });

      const days = DAILY.filter(d => d.spanH > 0 || d.boards > 0 || d.cut > 0 || d.waste > 0);

      if (!days.length) {
        document.getElementById("kpi-total-boards").textContent = "–";
        document.getElementById("kpi-avg-bph").textContent = "–";
        document.getElementById("kpi-avg-hours").textContent = "–";
        document.getElementById("kpi-total-cut").textContent = "–";
        document.getElementById("kpi-days").textContent = "0 days";
        document.getElementById("kpi-bph-note").textContent = "Top day: –";
        document.getElementById("kpi-hours-note").textContent = "–";
        document.getElementById("kpi-weight-note").textContent = "–";
        document.getElementById("chip-high-text").textContent = "–";
        document.getElementById("chip-mid-text").textContent = "–";
        document.getElementById("chip-low-text").textContent = "–";
        // Also reset footer totals
        const tfootRow = document.querySelector("#harvest-table tfoot tr");
        if (tfootRow) {
          const tds = tfootRow.querySelectorAll("td");
          if (tds.length >= 10) {
            tds[2].textContent = "0";
            tds[3].textContent = "0.0";
            tds[4].textContent = "0";
            tds[5].textContent = "0";
            tds[6].textContent = "0";
            tds[7].textContent = "0.0";
            tds[8].textContent = "0.0";
            tds[9].textContent = "0%";
          }
        }
        return;
      }

      const totalBoards = days.reduce((s,d)=>s+d.boards,0);
      const totalCut = days.reduce((s,d)=>s+d.cut,0);
      const totalWaste = days.reduce((s,d)=>s+d.waste,0);
      const totalWithWaste = days.reduce((s,d)=>s+d.withWaste,0);
      const totalSpanH = days.reduce((s,d)=>s+(d.spanH>0?d.spanH:0),0);

      const usedSpanDays = days.filter(d => d.spanH > 0);
      const avgBph = totalSpanH > 0 ? totalBoards / totalSpanH : 0;
      const avgHours = usedSpanDays.length > 0 ? totalSpanH / usedSpanDays.length : 0;

      const overallPotential = totalWithWaste > 0 ? (totalCut / totalWithWaste) * 100 : 0;
      const overallWastePct = 100 - overallPotential;

      let best = null, bestBph = 0;
      for (const d of usedSpanDays) {
        const b = d.spanH > 0 ? d.boards / d.spanH : 0;
        if (!best || b > bestBph) { best = d; bestBph = b; }
      }

      document.getElementById("kpi-total-boards").textContent = fmtInt(totalBoards);
      document.getElementById("kpi-avg-bph").textContent = fmt1(avgBph);
      document.getElementById("kpi-avg-hours").textContent = fmt1(avgHours);
      document.getElementById("kpi-total-cut").textContent = fmtInt(totalCut);

      document.getElementById("kpi-days").textContent = days.length + " harvest day" + (days.length === 1 ? "" : "s");
      document.getElementById("kpi-bph-note").textContent = best ? ("Top day: " + fmt1(bestBph) + " boards/hr (" + best.date + ")") : "Top day: –";
      document.getElementById("kpi-hours-note").textContent = "Total hours in field: " + fmt1(totalSpanH) + " hrs";
      document.getElementById("kpi-weight-note").textContent =
        "Waste: " + fmtInt(totalWaste) + " lbs (" + fmt1(overallWastePct) + "% of total) · With waste: " + fmtInt(totalWithWaste) + " lbs";

      let high=0, mid=0, low=0;
      days.forEach(d => {
        const p = d.potential || 0;
        if (p >= 95) high++;
        else if (p >= 85) mid++;
        else low++;
      });

      document.getElementById("chip-high-text").textContent = high + " day" + (high===1?"":"s") + " ≥ 95% potential";
      document.getElementById("chip-mid-text").textContent = mid + " day" + (mid===1?"":"s") + " between 85–94%";
      document.getElementById("chip-low-text").textContent = low + " day" + (low===1?"":"s") + " below 85%";

      const tfootRow = document.querySelector("#harvest-table tfoot tr");
      if (tfootRow) {
        const tds = tfootRow.querySelectorAll("td");
        if (tds.length >= 10) {
          const lbsPerBoard = totalBoards > 0 ? totalCut / totalBoards : 0;
          tds[2].textContent = fmtInt(totalBoards);
          tds[3].textContent = fmt1(totalSpanH);
          tds[4].textContent = fmtInt(totalCut);
          tds[5].textContent = fmtInt(totalWaste);
          tds[6].textContent = fmtInt(totalWithWaste);
          tds[7].textContent = fmt1(lbsPerBoard);
          tds[8].textContent = fmt1(avgBph);
          tds[9].textContent = fmt1(overallPotential) + "%";
        }
      }
    }

    // =========================================================
    // TABLE
    // =========================================================
    function renderTable() {
      const cutBody = document.getElementById("harvest-tbody-cut");
      const dailyBody = document.getElementById("harvest-tbody-daily");
      const weeklyBody = document.getElementById("harvest-tbody-weekly");
      if (!cutBody || !dailyBody || !weeklyBody) return;

      const fmtInt = (n) => n.toLocaleString(undefined, { maximumFractionDigits: 0 });
      const fmt1 = (n) => n.toLocaleString(undefined, { maximumFractionDigits: 1 });

      function pctClass(p) {
        if (p >= 95) return "cell-percent-good";
        if (p < 85) return "cell-percent-low";
        return "cell-percent-warn";
      }

      cutBody.innerHTML = "";
      CUTS.forEach(c => {
        const p = c.potential || 0;
        const spanH = (Number.isFinite(c.startMin) && Number.isFinite(c.finishMin))
          ? spanHoursFromMinMax(c.startMin, c.finishMin)
          : 0;

        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${c.date || "–"}</td>
          <td>${c.week || "–"}</td>
          <td>${fmtInt(c.boards)}</td>
          <td>${fmt1(spanH)}</td>
          <td>${fmtInt(c.cut)}</td>
          <td>${fmtInt(c.waste)}</td>
          <td>${fmtInt(c.withWaste)}</td>
          <td>${fmt1(c.lbsPerBoard)}</td>
          <td>${fmt1(c.bph)}</td>
          <td><span class="cell-pill ${pctClass(p)}">${p.toFixed(0)}%</span></td>
        `;
        cutBody.appendChild(tr);
      });

      // --- FIX: daily table should show newest first (human-friendly)
      dailyBody.innerHTML = "";
      const dailySorted = [...DAILY].sort((a,b) => b.dateObj - a.dateObj);
      dailySorted.forEach(d => {
        const p = d.potential || 0;
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${d.date}</td>
          <td>–</td>
          <td>${fmtInt(d.boards)}</td>
          <td>${fmt1(d.spanH)}</td>
          <td>${fmtInt(d.cut)}</td>
          <td>${fmtInt(d.waste)}</td>
          <td>${fmtInt(d.withWaste)}</td>
          <td>${fmt1(d.lbsPerBoard)}</td>
          <td>${fmt1(d.bph)}</td>
          <td><span class="cell-pill ${pctClass(p)}">${p.toFixed(0)}%</span></td>
        `;
        dailyBody.appendChild(tr);
      });

      weeklyBody.innerHTML = "";
      WEEKLY.forEach(w => {
        const p = w.potential || 0;
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>Week ${w.week}</td>
          <td>${w.week}</td>
          <td>${fmtInt(w.boards)}</td>
          <td>${fmt1(w.spanH)}</td>
          <td>${fmtInt(w.cut)}</td>
          <td>${fmtInt(w.waste)}</td>
          <td>${fmtInt(w.withWaste)}</td>
          <td>${fmt1(w.lbsPerBoard)}</td>
          <td>${fmt1(w.bph)}</td>
          <td><span class="cell-pill ${pctClass(p)}">${p.toFixed(0)}%</span></td>
        `;
        weeklyBody.appendChild(tr);
      });
    }

    // =========================================================
    // CHARTS
    // =========================================================
    function renderCharts() {
      const labelsCut = CUTS.map((c, i) => c.date ? `${c.date} #${i+1}` : String(i+1));
      const boardsByCut = CUTS.map(c => c.boards);
      const bphByCut = CUTS.map(c => c.bph);
      const cutByCut = CUTS.map(c => c.cut);
      const withWasteByCut = CUTS.map(c => c.withWaste);

      // --- FIX: always force daily chart data to be chronological (oldest -> newest)
      const dailyChrono = [...DAILY].sort((a,b) => a.dateObj - b.dateObj);
      const labelsByDate = dailyChrono.map(d => d.date);
      const boardsByDate = dailyChrono.map(d => d.boards);
      const bphByDate = dailyChrono.map(d => d.bph);
      const cutByDate = dailyChrono.map(d => d.cut);
      const withWasteByDate = dailyChrono.map(d => d.withWaste);

      const labelsByWeek = WEEKLY.map(w => String(w.week));
      const boardsByWeek = WEEKLY.map(w => w.boards);
      const bphByWeek = WEEKLY.map(w => w.bph);
      const cutByWeek = WEEKLY.map(w => w.cut);
      const withWasteByWeek = WEEKLY.map(w => w.withWaste);

      let labels, boardsValues, bphValues, weightValues, weightTargetValues;
      const isWeekly = chartMode === "week";
      const isDaily = chartMode === "date";
      if (chartMode === "cut") {
        labels = labelsCut; boardsValues = boardsByCut; bphValues = bphByCut;
        weightValues = cutByCut; weightTargetValues = withWasteByCut;
      } else if (chartMode === "week") {
        labels = labelsByWeek; boardsValues = boardsByWeek; bphValues = bphByWeek;
        weightValues = cutByWeek; weightTargetValues = withWasteByWeek;
      } else {
        labels = labelsByDate; boardsValues = boardsByDate; bphValues = bphByDate;
        weightValues = cutByDate; weightTargetValues = withWasteByDate;
      }

      const ctxBoards = document.getElementById("chart-boards")?.getContext("2d");
      const ctxWeight = document.getElementById("chart-weight")?.getContext("2d");
      const ctxBph = document.getElementById("chart-bph")?.getContext("2d");
      if (!ctxBoards || !ctxWeight || !ctxBph) return;

      if (boardsChart) boardsChart.destroy();
      if (weightChart) weightChart.destroy();
      if (bphChart) bphChart.destroy();

      boardsChart = new Chart(ctxBoards, {
        type: "bar",
        data: {
          labels,
          datasets: [{
            label: chartMode === "cut" ? "Boards per cut" : chartMode === "week" ? "Boards per week" : "Boards per day",
            data: boardsValues,
            borderWidth: 0,
            borderRadius: 4,
            backgroundColor: "rgba(59, 130, 246, 0.85)"
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: { legend: { display: false } },
          interaction: { mode: "index", intersect: false },
          scales: {
            x: {
              grid: { display: false },
              ticks: { color: "rgba(148, 163, 184, 0.9)", maxRotation: 0, autoSkip: true, autoSkipPadding: 18 },
              title: { display: isWeekly || isDaily, text: isWeekly ? "Week" : "Date", color: "rgba(148, 163, 184, 0.9)", font: { size: 10 } }
            },
            y: {
              grid: { color: "rgba(31, 41, 55, 0.8)" },
              ticks: { color: "rgba(148, 163, 184, 0.9)" },
              title: { display: isWeekly || isDaily, text: "Boards", color: "rgba(148, 163, 184, 0.9)", font: { size: 10 } }
            }
          }
        }
      });

      weightChart = new Chart(ctxWeight, {
        type: "bar",
        data: {
          labels,
          datasets: [
            { label: "Cut lbs", data: weightValues, borderWidth: 0, borderRadius: 4, backgroundColor: "rgba(234, 179, 8, 0.9)" },
            { label: "With waste (target)", data: weightTargetValues, type: "line", tension: 0.35, borderWidth: 2, pointRadius: 2.8, fill: false, borderColor: "rgba(148, 163, 184, 0.9)" }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: { legend: { display: true, labels: { color: "rgba(209, 213, 219, 0.9)", font: { size: 10 } } } },
          interaction: { mode: "index", intersect: false },
          scales: {
            x: {
              grid: { display: false },
              ticks: { color: "rgba(148, 163, 184, 0.9)" },
              title: { display: isWeekly || isDaily, text: isWeekly ? "Week" : "Date", color: "rgba(148, 163, 184, 0.9)", font: { size: 10 } }
            },
            y: {
              grid: { color: "rgba(31, 41, 55, 0.8)" },
              ticks: { color: "rgba(148, 163, 184, 0.9)" },
              title: { display: isWeekly || isDaily, text: "Lbs", color: "rgba(148, 163, 184, 0.9)", font: { size: 10 } }
            }
          }
        }
      });

      const bphDatasets = [{
        label: "Boards / hour",
        data: bphValues,
        tension: 0.35,
        borderWidth: 2.2,
        pointRadius: 2.8,
        fill: false,
        borderColor: "rgba(34, 197, 94, 0.9)"
      }];

      if (showTrendLine) {
        const trend = computeTrendLine(bphValues);
        if (trend.length === bphValues.length) {
          bphDatasets.push({
            label: "Trend",
            data: trend,
            tension: 0,
            borderWidth: 1.8,
            pointRadius: 0,
            fill: false,
            borderDash: [5, 4],
            borderColor: "rgba(148, 163, 184, 0.8)"
          });
        }
      }

      bphChart = new Chart(ctxBph, {
        type: "line",
        data: { labels, datasets: bphDatasets },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: { legend: { display: false } },
          interaction: { mode: "index", intersect: false },
          scales: {
            x: {
              grid: { display: false },
              ticks: { color: "rgba(148, 163, 184, 0.9)" },
              title: { display: isWeekly || isDaily, text: isWeekly ? "Week" : "Date", color: "rgba(148, 163, 184, 0.9)", font: { size: 10 } }
            },
            y: {
              grid: { color: "rgba(31, 41, 55, 0.8)" },
              ticks: { color: "rgba(148, 163, 184, 0.9)" },
              title: { display: isWeekly || isDaily, text: "Boards / hour", color: "rgba(148, 163, 184, 0.9)", font: { size: 10 } }
            }
          }
        }
      });
    }

    // =========================================================
    // MODE TOGGLES
    // =========================================================
    function setChartMode(mode, opts = {}) {
      const { fromTable = false } = opts;
      chartMode = mode;

      document.getElementById("view-by-cut")?.classList.toggle("active", mode === "cut");
      document.getElementById("view-by-date")?.classList.toggle("active", mode === "date");
      document.getElementById("view-by-week")?.classList.toggle("active", mode === "week");

      if (!fromTable) {
        setTableMode(mode === "date" ? "daily" : mode === "week" ? "weekly" : "cut", { fromChart: true });
        renderCharts();
      } else {
        renderCharts();
      }
    }

    function setTableMode(mode, opts = {}) {
      const { fromChart = false } = opts;
      tableMode = mode;

      const isCut = mode === "cut";
      const isDaily = mode === "daily";
      const isWeekly = mode === "weekly";

      document.getElementById("harvest-tbody-cut")?.classList.toggle("hidden", !isCut);
      document.getElementById("harvest-tbody-daily")?.classList.toggle("hidden", !isDaily);
      document.getElementById("harvest-tbody-weekly")?.classList.toggle("hidden", !isWeekly);

      document.getElementById("table-view-cut")?.classList.toggle("active", isCut);
      document.getElementById("table-view-daily")?.classList.toggle("active", isDaily);
      document.getElementById("table-view-weekly")?.classList.toggle("active", isWeekly);

      const titleEl = document.getElementById("harvest-table-title");
      const subEl = document.getElementById("harvest-table-subtitle");
      const hintEl = document.getElementById("harvest-table-hint");

      if (titleEl) titleEl.textContent = isCut ? "Cut-level harvest log" : isDaily ? "Daily harvest summary" : "Weekly harvest summary";
      if (subEl) subEl.textContent = isCut
        ? "Each row is a harvest cut loaded from Master Grow."
        : isDaily
          ? "Daily totals aggregated from cuts (span uses earliest start → latest finish per day)."
          : "Aggregated by harvest week (built from daily totals).";
      if (hintEl) hintEl.textContent = isCut ? "Scroll to see all cuts" : isDaily ? "Scroll to see all days" : "Scroll to see all weeks";

      if (!fromChart) setChartMode(isDaily ? "date" : isWeekly ? "week" : "cut", { fromTable: true });
      else renderTable();
    }

    function setupUI() {
      document.getElementById("view-by-cut")?.addEventListener("click", () => setChartMode("cut"));
      document.getElementById("view-by-date")?.addEventListener("click", () => setChartMode("date"));
      document.getElementById("view-by-week")?.addEventListener("click", () => setChartMode("week"));

      document.getElementById("table-view-cut")?.addEventListener("click", () => setTableMode("cut"));
      document.getElementById("table-view-daily")?.addEventListener("click", () => setTableMode("daily"));
      document.getElementById("table-view-weekly")?.addEventListener("click", () => setTableMode("weekly"));

      document.getElementById("trend-toggle-input")?.addEventListener("change", (e) => {
        showTrendLine = !!e.target.checked;
        renderCharts();
      });

      setChartMode(chartMode);
      setTableMode(tableMode);
    }

    // =========================================================
    // LIVE REFRESH (bulletproof: debounce + poll + bc + message)
    // =========================================================
    let reloadTimer = null;
    function reloadAll(reason){
      if (reloadTimer) clearTimeout(reloadTimer);
      reloadTimer = setTimeout(() => {
        reloadTimer = null;
        buildModels();
        renderKPIs();
        renderTable();
        renderCharts();
        // console.log("🔄 Harvest reload", reason || "");
      }, 60);
    }

    function setupListeners() {
      // 1) storage
      window.addEventListener("storage", (e) => {
        if (!e) return;
        if (e.key === MASTER_GROW_KEY || e.key === MASTER_GROW_PING_KEY) reloadAll("storage");
      });

      // 2) CustomEvent (same frame)
      window.addEventListener(MSG_GROW, () => reloadAll("customevent"));
      document.addEventListener(MSG_GROW, () => reloadAll("customevent-doc"));

      // 3) postMessage from index/data input
      window.addEventListener("message", (event) => {
        const msg = event?.data;
        if (!msg || typeof msg !== "object") return;
        if (msg.type === MSG_GROW || msg.type === "MASTER_GROW_UPDATED") reloadAll("message");
      });

      // 4) BroadcastChannel
      if (bc) {
        bc.onmessage = (ev) => {
          const msg = ev?.data;
          if (msg?.type === MSG_GROW) reloadAll("broadcast");
        };
      }

      // 5) Safety poll (Safari iframe oddities)
      let lastLen = (localStorage.getItem(MASTER_GROW_KEY) || "").length;
      setInterval(() => {
        const curLen = (localStorage.getItem(MASTER_GROW_KEY) || "").length;
        if (curLen !== lastLen) {
          lastLen = curLen;
          reloadAll("poll");
        }
      }, 1500);
    }

    document.addEventListener("DOMContentLoaded", () => {
      setupUI();
      setupListeners();
      reloadAll("init");
    });
  </script>
</body>
</html>
