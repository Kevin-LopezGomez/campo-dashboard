<script>
  (function(){
    // =========================
    // Cloudflare Worker gateway (ONLY data connection)
    // =========================
    const WORKER_BASE = "https://campo-publisher.kevin-lopezgomez.workers.dev";
    const WORKER_HEALTH_URL = `${WORKER_BASE}/health`;
    const WORKER_GROW_URL   = `${WORKER_BASE}/data/master/grow.json`;
    const WORKER_PACK_URL   = `${WORKER_BASE}/data/master/pack.json`;

    // =========================
    // LocalStorage keys (MUST match dashboards)
    // =========================
    const MASTER_GROW_KEY  = "campo_master_grow_v1";
    const MASTER_PACK_KEY  = "campo_master_pack_v1";
    const MASTER_GROW_PING = "campo_master_grow_push_ping_v1";
    const MASTER_PACK_PING = "campo_master_pack_push_ping_v1";

    // Message types your dashboards already listen for
    const MSG_GROW = "MASTER_GROW_UPDATED";
    const MSG_PACK = "MASTER_PACK_UPDATED";

    const tabsWrap = document.getElementById("tabs");
    const panels = Array.from(document.querySelectorAll(".panel"));
    const LS_ORDER_KEY = "campo_unified_tabs_order_v1";

    // -------------------------
    // Small helpers
    // -------------------------
    function upsertBadge(text, ok){
      let badge = document.getElementById("__sb_badge");
      if (!badge){
        badge = document.createElement("div");
        badge.id = "__sb_badge";
        badge.style.position = "fixed";
        badge.style.bottom = "12px";
        badge.style.right = "12px";
        badge.style.padding = "8px 12px";
        badge.style.borderRadius = "8px";
        badge.style.fontSize = "12px";
        badge.style.zIndex = 9999;
        badge.style.boxShadow = "0 10px 24px rgba(0,0,0,.35)";
        document.body.appendChild(badge);
      }
      badge.textContent = text;
      badge.style.background = ok ? "#16a34a" : "#b91c1c";
      badge.style.color = "white";
    }

    function dispatchLocal(type, key){
      try { window.dispatchEvent(new CustomEvent(type, { detail: { key, ts: Date.now() } })); } catch(e) {}
      try { document.dispatchEvent(new CustomEvent(type, { detail: { key, ts: Date.now() } })); } catch(e) {}
    }

    function notifyIframes(type){
      const targets = {
        "MASTER_GROW_UPDATED": ["ifr-seeding","ifr-transplant","ifr-sanitation","ifr-harvest","ifr-packing","ifr-data"],
        "MASTER_PACK_UPDATED": ["ifr-seeding","ifr-transplant","ifr-sanitation","ifr-harvest","ifr-packing","ifr-data"],
      }[type] || [];

      for (const id of targets){
        const ifr = document.getElementById(id);
        if (ifr?.contentWindow) {
          try { ifr.contentWindow.postMessage({ type, ts: Date.now() }, "*"); } catch(e) {}
        }
      }
    }

    async function workerGetJson(url){
      const bust = url + (url.includes("?") ? "&" : "?") + "ts=" + Date.now();
      const r = await fetch(bust, { cache: "no-store" });
      const t = await r.text();
      if (!r.ok) throw new Error(`HTTP ${r.status}: ${t}`);
      return JSON.parse(t);
    }

    // -------------------------
    // Hydrate localStorage from Worker (public read)
    // -------------------------
    async function tryHydrateFromWorker(){
      // 1) quick health check (optional but nice)
      try{
        const hr = await fetch(WORKER_HEALTH_URL, { cache: "no-store" });
        if (!hr.ok) throw new Error(`Health HTTP ${hr.status}`);
        upsertBadge("Worker connected", true);
      } catch(err){
        console.error("❌ Worker health failed:", err);
        upsertBadge("Worker not reachable", false);
        return;
      }

      // 2) pull grow/pack JSON into localStorage (same keys dashboards use)
      let wroteAny = false;

      try{
        const growJson = await workerGetJson(WORKER_GROW_URL);
        localStorage.setItem(MASTER_GROW_KEY, JSON.stringify(growJson));
        localStorage.setItem(MASTER_GROW_PING, String(Date.now()));
        dispatchLocal(MSG_GROW, MASTER_GROW_KEY);
        notifyIframes(MSG_GROW);
        wroteAny = true;
      } catch(e){
        console.warn("Grow load failed:", e);
      }

      try{
        const packJson = await workerGetJson(WORKER_PACK_URL);
        localStorage.setItem(MASTER_PACK_KEY, JSON.stringify(packJson));
        localStorage.setItem(MASTER_PACK_PING, String(Date.now()));
        dispatchLocal(MSG_PACK, MASTER_PACK_KEY);
        notifyIframes(MSG_PACK);
        wroteAny = true;
      } catch(e){
        console.warn("Pack load failed:", e);
      }

      if (wroteAny){
        console.log("✅ Hydrated localStorage from Worker (grow/pack).");
      } else {
        console.log("ℹ️ Worker connected, but grow/pack not loaded (missing files or blocked).");
      }
    }

    // ---------- Panel activation ----------
    function activate(id){
      const tabs = Array.from(tabsWrap.querySelectorAll(".tab"));
      tabs.forEach(t => t.classList.toggle("active", t.dataset.target === id));
      panels.forEach(p => p.classList.toggle("active", p.id === id));

      const panel = document.getElementById(id);
      const iframe = panel ? panel.querySelector("iframe[data-src]") : null;
      if (iframe && !iframe.src) iframe.src = iframe.getAttribute("data-src");
    }

    // ---------- Restore / Save order ----------
    function loadOrder(){
      try { return JSON.parse(localStorage.getItem(LS_ORDER_KEY) || "[]"); }
      catch(e){ return []; }
    }
    function saveOrder(){
      const ids = Array.from(tabsWrap.querySelectorAll(".tab")).map(t => t.dataset.tab);
      try { localStorage.setItem(LS_ORDER_KEY, JSON.stringify(ids)); } catch(e){}
    }
    function applySavedOrder(){
      const order = loadOrder();
      if (!order.length) return;
      const map = new Map(Array.from(tabsWrap.querySelectorAll(".tab")).map(t => [t.dataset.tab, t]));
      order.forEach(id => {
        const el = map.get(id);
        if (el) tabsWrap.appendChild(el);
      });
    }

    // ---------- Drag-to-reorder with threshold (click still works) ----------
    function makeSortable(){
      const DRAG_THRESHOLD = 8;

      let downTab = null;
      let isDragging = false;
      let placeholder = null;
      let offsetX = 0, offsetY = 0;
      let startX = 0, startY = 0;

      function pointerXY(e){
        const p = e.touches ? e.touches[0] : e;
        return { x: p.clientX, y: p.clientY };
      }

      function startDrag(tab, x, y){
        isDragging = true;

        const rect = tab.getBoundingClientRect();
        offsetX = x - rect.left;
        offsetY = y - rect.top;

        placeholder = tab.cloneNode(true);
        placeholder.classList.remove("active");
        placeholder.classList.add("placeholder");
        placeholder.style.width = rect.width + "px";
        placeholder.style.height = rect.height + "px";

        tabsWrap.insertBefore(placeholder, tab.nextSibling);

        tab.classList.add("dragging");
        tab.style.width = rect.width + "px";
        tab.style.height = rect.height + "px";
        tab.style.left = rect.left + "px";
        tab.style.top  = rect.top  + "px";
        tab.style.cursor = "grabbing";
      }

      function moveDrag(tab, x, y){
        tab.style.left = (x - offsetX) + "px";
        tab.style.top  = (y - offsetY) + "px";

        const tabs = Array.from(tabsWrap.querySelectorAll(".tab"))
          .filter(t => t !== tab && t !== placeholder);

        let inserted = false;
        for (const t of tabs) {
          const r = t.getBoundingClientRect();
          const tCenter = r.left + r.width/2;
          if (x < tCenter) {
            tabsWrap.insertBefore(placeholder, t);
            inserted = true;
            break;
          }
        }
        if (!inserted) tabsWrap.appendChild(placeholder);

        const wrapRect = tabsWrap.getBoundingClientRect();
        const edge = 36;
        if (x < wrapRect.left + edge) tabsWrap.scrollLeft -= 10;
        if (x > wrapRect.right - edge) tabsWrap.scrollLeft += 10;
      }

      function endDrag(tab){
        tab.classList.remove("dragging");
        tab.style.left = "";
        tab.style.top  = "";
        tab.style.width = "";
        tab.style.height = "";
        tab.style.cursor = "";

        if (placeholder) {
          tabsWrap.insertBefore(tab, placeholder);
          placeholder.remove();
          placeholder = null;
        }

        saveOrder();
        isDragging = false;
      }

      function cleanupListeners(){
        window.removeEventListener("mousemove", onMove);
        window.removeEventListener("mouseup", onUp);
        window.removeEventListener("touchmove", onMove);
        window.removeEventListener("touchend", onUp);
      }

      function onDown(e){
        const tab = e.target.closest(".tab");
        if (!tab) return;

        downTab = tab;
        isDragging = false;
        const {x,y} = pointerXY(e);
        startX = x; startY = y;

        window.addEventListener("mousemove", onMove, { passive:false });
        window.addEventListener("mouseup", onUp, { passive:true });
        window.addEventListener("touchmove", onMove, { passive:false });
        window.addEventListener("touchend", onUp, { passive:true });
      }

      function onMove(e){
        if (!downTab) return;

        const {x,y} = pointerXY(e);
        const dx = x - startX;
        const dy = y - startY;

        if (!isDragging) {
          if (Math.hypot(dx, dy) < DRAG_THRESHOLD) return;
          e.preventDefault();
          startDrag(downTab, x, y);
        } else {
          e.preventDefault();
          moveDrag(downTab, x, y);
        }
      }

      function onUp(){
        cleanupListeners();
        if (!downTab) return;

        if (isDragging) endDrag(downTab);
        else activate(downTab.dataset.target);

        downTab = null;
      }

      tabsWrap.addEventListener("mousedown", onDown);
      tabsWrap.addEventListener("touchstart", onDown, { passive:true });
    }

    // ---------- init ----------
    applySavedOrder();
    makeSortable();

    const firstActive = tabsWrap.querySelector(".tab.active") || tabsWrap.querySelector(".tab");
    if (firstActive) activate(firstActive.dataset.target);

    // Forward update pings into the right iframe (existing behavior)
    window.addEventListener("message", (event) => {
      const msg = event?.data || {};
      if (!msg.type) return;

      const map = {
        "HARVEST_DATA_UPDATED": "ifr-harvest",
        "PACKING_DATA_UPDATED": "ifr-packing",
        "SANITATION_DATA_UPDATED": "ifr-sanitation",
        "SEEDING_DATA_UPDATED": "ifr-seeding",
        "TRANSPLANT_DATA_UPDATED": "ifr-transplant",
        "MASTER_GROW_UPDATED": null,
        "MASTER_PACK_UPDATED": null
      };

      if (map[msg.type]) {
        const ifr = document.getElementById(map[msg.type]);
        if (ifr?.contentWindow) ifr.contentWindow.postMessage({ type: msg.type, ts: msg.ts }, "*");
      }
    });

    // IMPORTANT: hydrate localStorage from Worker on page load
    tryHydrateFromWorker();
  })();
</script>
