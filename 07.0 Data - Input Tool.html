<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Data Input ‚Äì Grow / Pack / Experiments / Procurement</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- SheetJS (Excel reader) -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <style>
    :root{
      --bg:#020617;
      --panel:#0b1222;
      --border:#1f2937;
      --text:#e5e7eb;
      --sub:#9ca3af;
      --accent:#22c55e;
      --danger:#ef4444;
      --warn:#f59e0b;
    }
    *{box-sizing:border-box;}
    body{
      margin:0;
      font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
      background: radial-gradient(circle at top, #111827 0, #020617 55%, #000 100%);
      color:var(--text);
    }
    .wrap{max-width:1200px;margin:20px auto;padding:16px;}
    h1{margin:0;font-size:1.2rem;}
    p{color:var(--sub);font-size:.85rem;line-height:1.35;margin:.4rem 0 0;}
    .panel{
      background: radial-gradient(circle at top left, rgba(15,23,42,.94), rgba(15,23,42,.98));
      border:1px solid rgba(55,65,81,.9);
      border-radius:16px;
      padding:16px;
      margin-top:16px;
      box-shadow: 0 18px 40px rgba(0,0,0,.55);
    }
    .row{display:grid;grid-template-columns:1.4fr 1fr;gap:16px;}
    @media(max-width:900px){.row{grid-template-columns:1fr;}}
    .drop{
      border:1px dashed rgba(148,163,184,.45);
      border-radius:14px;
      padding:18px;
      min-height:170px;
      display:flex;
      flex-direction:column;
      justify-content:center;
      gap:10px;
      background: rgba(2,6,23,.25);
    }
    .drop.dragover{border-color: rgba(34,197,94,.8);background: rgba(34,197,94,.08);}
    .btnrow{display:flex;flex-wrap:wrap;gap:8px;}
    button{
      background: rgba(15,23,42,.95);
      border:1px solid rgba(55,65,81,.9);
      color:var(--text);
      border-radius:999px;
      padding:7px 12px;
      cursor:pointer;
      font-size:.8rem;
      display:inline-flex;align-items:center;gap:8px;
      transition: transform .06s ease, opacity .12s ease;
    }
    button:active{transform:scale(.99);}
    button.primary{
      background: radial-gradient(circle at 0 0, rgba(34,197,94,.28), rgba(22,163,74,.95));
      border-color: rgba(34,197,94,.9);
      box-shadow: 0 9px 26px rgba(16,185,129,.20);
    }
    button.danger{
      background: radial-gradient(circle at 0 0, rgba(239,68,68,.20), rgba(127,29,29,.85));
      border-color: rgba(239,68,68,.75);
    }
    button.ghost{
      background: rgba(2,6,23,.35);
      border-color: rgba(55,65,81,.75);
    }
    button[disabled]{opacity:.45;cursor:not-allowed;}

    .meta{
      border:1px solid rgba(31,41,55,.85);
      border-radius:14px;
      padding:12px;
      background: rgba(2,6,23,.25);
      display:grid;
      gap:10px;
    }
    .kv{display:flex;justify-content:space-between;gap:10px;color:var(--sub);font-size:.82rem;}
    .kv b{color:var(--text);}
    .tag{
      border:1px solid rgba(148,163,184,.25);
      border-radius:999px;
      padding:2px 8px;
      font-size:.72rem;
      background: rgba(2,6,23,.35);
      color:var(--sub);
      display:inline-flex;align-items:center;gap:6px;
      white-space:nowrap;
    }
    .dot{width:7px;height:7px;border-radius:999px;background:var(--accent);box-shadow:0 0 0 3px rgba(34,197,94,.2);}
    .dot.bad{background:var(--danger);box-shadow:0 0 0 3px rgba(239,68,68,.16);}
    .small{font-size:.76rem;color:var(--sub);line-height:1.35;}
    .preview{
      max-height:340px;
      overflow:auto;
      border:1px solid rgba(31,41,55,.85);
      border-radius:12px;
      margin-top:12px;
      background: rgba(2,6,23,.20);
    }
    table{width:100%;border-collapse:collapse;font-size:.75rem;min-width:900px;}
    th,td{padding:6px 10px;border-bottom:1px solid rgba(31,41,55,.75);white-space:nowrap;}
    th{color:var(--sub);text-transform:uppercase;font-size:.7rem;letter-spacing:.12em;position:sticky;top:0;background: rgba(2,6,23,.85);}

    .hint{
      margin-top:8px;
      padding:10px 12px;
      border:1px solid rgba(55,65,81,.75);
      border-radius:12px;
      background: rgba(2,6,23,.28);
    }
    code{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;font-size:.78rem;color:#c7d2fe;}
    .warnline{color:#fbbf24;}
  </style>
</head>

<body>
<div class="wrap">
  <h1>Data Input ‚Äì Grow / Pack / Experiments / Procurement</h1>
  <p>
    Supported: <b>1 XLSX</b> (multiple sheets) or <b>separate CSVs</b> for <b>Grow</b>, <b>Pack</b>, <b>Current Experiments</b>, and <b>Procurement</b>. Uploading a new file will <b>overwrite</b> only that dataset‚Äôs stored JSON.
  </p>

  <div class="panel">
    <div class="row">
      <div class="drop" id="dropzone">
        <strong>Drop .xlsx or .csv here</strong>
        <span class="small">If CSV filename includes ‚Äúgrow‚Äù or ‚Äúpack‚Äù, it auto-assigns. Otherwise use the assign buttons.</span>

        <input id="fileInput" type="file" accept=".xlsx,.xls,.csv,text/csv" hidden />

        <div class="btnrow">
          <button class="primary" id="chooseBtn" type="button">üìÑ Choose File</button>
          <button id="assignGrowBtn" type="button" disabled>üß© Assign last CSV ‚Üí Master Grow</button>
          <button id="assignPackBtn" type="button" disabled>üì¶ Assign last CSV ‚Üí Master Pack</button>
          <button id="assignExpBtn" type="button" disabled>üß™ Assign last CSV ‚Üí Current Experiments</button>
          <button id="assignProcBtn" type="button" disabled>üßæ Assign last CSV ‚Üí Procurement</button>
          <button class="danger" id="clearBtn" type="button">‚úï Clear Stored Sources</button>
        </div>

        <div class="btnrow" style="margin-top:6px;">
          <button class="ghost" id="downloadGrowBtn" type="button">‚¨áÔ∏è Download grow.json</button>
          <button class="ghost" id="downloadPackBtn" type="button">‚¨áÔ∏è Download pack.json</button>
          <button class="ghost" id="downloadExpBtn" type="button">‚¨áÔ∏è Download experiments.json</button>
          <button class="ghost" id="downloadProcBtn" type="button">‚¨áÔ∏è Download procurement.json</button>
          <button class="ghost" id="pullBtn" type="button">‚¨áÔ∏è Pull from Supabase</button>
          <button class="primary" id="publishBtn" type="button">üöÄ Publish to Supabase</button>
        </div>

        <div class="hint small">
          <b>Bulletproof contract:</b> this tool always saves Excel/CSV into:
          <br>
          <code>payload.sheets["Master Grow"]</code> and <code>payload.sheets["Master Pack"]</code>
          <br><br>
          Uploads save JSON into <code>localStorage</code> so dashboards read immediately.
          ‚ÄúPublish / Pull‚Äù uses your Cloudflare Worker as the Supabase gateway.
          <br><br>
          Worker endpoints:
          <code>GET /data/master/grow.json</code>, <code>GET /data/master/pack.json</code>, <code>GET /data/master/experiments.json</code>, <code>GET /data/master/procurement.json</code>,
          <br>
          <code>PUT /data/master/grow.json</code>, <code>PUT /data/master/pack.json</code>, <code>PUT /data/master/experiments.json</code>, <code>PUT /data/master/procurement.json</code>.
        </div>

        <div id="status" class="small">Waiting for file‚Ä¶</div>
        <div id="contractWarn" class="small warnline" style="display:none;"></div>
      </div>

      <div class="meta">
        <div class="kv"><span>Master Grow</span><span class="tag" id="growTag"><span class="dot bad"></span>Missing</span></div>
        <div class="kv"><span>Master Pack</span><span class="tag" id="packTag"><span class="dot bad"></span>Missing</span></div>
        <div class="kv"><span>Current Experiments</span><span class="tag" id="expTag"><span class="dot bad"></span>Missing</span></div>
        <div class="kv"><span>Procurement</span><span class="tag" id="procTag"><span class="dot bad"></span>Missing</span></div>
        <div class="kv"><span>Grow updated</span><b id="growUpdated">‚Äì</b></div>
        <div class="kv"><span>Pack updated</span><b id="packUpdated">‚Äì</b></div>
        <div class="kv"><span>Experiments updated</span><b id="expUpdated">‚Äì</b></div>
        <div class="kv"><span>Procurement updated</span><b id="procUpdated">‚Äì</b></div>
        <div class="small" id="fileMeta">Last file: ‚Äì</div>
      </div>
    </div>

    <div class="preview" id="preview">
      <div class="small" style="padding:10px;">Upload a file to preview data.</div>
    </div>
  </div>
</div>

<script>
  // =========================================================
  // CONFIG
// =========================================================
const WORKER_BASE = "https://campo-publisher.kevin-lopezgomez.workers.dev";
const WORKER_HEALTH_URL = `${WORKER_BASE}/health`;
const WORKER_GROW_URL = `${WORKER_BASE}/data/master/grow.json`;
const WORKER_PACK_URL = `${WORKER_BASE}/data/master/pack.json`;
const WORKER_EXP_URL  = `${WORKER_BASE}/data/master/experiments.json`;
const WORKER_PROC_URL = `${WORKER_BASE}/data/master/procurement.json`;


  // Storage keys (must match dashboards)
const MASTER_GROW_KEY = "campo_master_grow_v1";
const MASTER_PACK_KEY = "campo_master_pack_v1";
const MASTER_EXP_KEY  = "campo_master_experiments_v1";
const MASTER_PROC_KEY = "campo_master_procurement_v1";

const MASTER_GROW_PING = "campo_master_grow_push_ping_v1";
const MASTER_PACK_PING = "campo_master_pack_push_ping_v1";
const MASTER_EXP_PING  = "campo_master_experiments_push_ping_v1";
const MASTER_PROC_PING = "campo_master_procurement_push_ping_v1";


  // Canonical sheet keys (contract)
const CANON_GROW_SHEET = "Master Grow";
const CANON_PACK_SHEET = "Master Pack";
const CANON_EXP_SHEET  = "Current Experiments";
const CANON_PROC_SHEET = "Procurement";


  // Message types
const MSG_GROW = "MASTER_GROW_UPDATED";
const MSG_PACK = "MASTER_PACK_UPDATED";
const MSG_EXP  = "EXPERIMENTS_UPDATED";
const MSG_PROC = "PROCUREMENT_UPDATED";


  // BroadcastChannel for same-origin pages (index + dashboards)
  const BC_NAME = "campo_updates_v1";
  const bc = (() => {
    try { return ("BroadcastChannel" in window) ? new BroadcastChannel(BC_NAME) : null; }
    catch { return null; }
  })();

  // =========================================================
  // UI REFS
  // =========================================================
  const dropzone = document.getElementById("dropzone");
  const fileInput = document.getElementById("fileInput");
  const chooseBtn = document.getElementById("chooseBtn");
  const assignGrowBtn = document.getElementById("assignGrowBtn");
  const assignPackBtn = document.getElementById("assignPackBtn");
const assignExpBtn  = document.getElementById("assignExpBtn");
const assignProcBtn = document.getElementById("assignProcBtn");
const clearBtn = document.getElementById("clearBtn");
const downloadGrowBtn = document.getElementById("downloadGrowBtn");
const downloadPackBtn = document.getElementById("downloadPackBtn");
const downloadExpBtn  = document.getElementById("downloadExpBtn");
const downloadProcBtn = document.getElementById("downloadProcBtn");

  const publishBtn = document.getElementById("publishBtn");
  const pullBtn = document.getElementById("pullBtn");
  const statusEl = document.getElementById("status");
  const previewEl = document.getElementById("preview");
  const growTag = document.getElementById("growTag");
  const packTag = document.getElementById("packTag");
const expTag  = document.getElementById("expTag");
const procTag = document.getElementById("procTag");
const growUpdated = document.getElementById("growUpdated");
const packUpdated = document.getElementById("packUpdated");
const expUpdated  = document.getElementById("expUpdated");
const procUpdated = document.getElementById("procUpdated");
const fileMeta = document.getElementById("fileMeta");

  const contractWarn = document.getElementById("contractWarn");

  function setStatus(msg){ statusEl.textContent = msg; }
  function norm(s){ return String(s||"").trim().toLowerCase(); }

  function showContractWarning(msg){
    if (!contractWarn) return;
    if (!msg){
      contractWarn.style.display = "none";
      contractWarn.textContent = "";
      return;
    }
    contractWarn.style.display = "block";
    contractWarn.textContent = msg;
  }

  // =========================================================
  // EVENTS (bulletproof propagation)
  // =========================================================
  function emit(type, key){
    const payload = { type, key, ts: Date.now() };

    // 1) postMessage to parent (index iframe wrapper)
    try { window.parent?.postMessage?.(payload, "*"); } catch(e){}

    // 2) BroadcastChannel (same-origin only)
    try { bc?.postMessage?.(payload); } catch(e){}

    // 3) CustomEvent in this frame (some dashboards listen)
    try { window.dispatchEvent(new CustomEvent(type, { detail: payload })); } catch(e){}
    try { document.dispatchEvent(new CustomEvent(type, { detail: payload })); } catch(e){}
  }

  // =========================================================
  // BADGES
  // =========================================================
  function setTag(el, ok){
    el.innerHTML = ok
      ? `<span class="dot"></span>Loaded`
      : `<span class="dot bad"></span>Missing`;
  }
  function fmtTs(ts){
    if(!ts) return "‚Äì";
    const d = new Date(Number(ts));
    if(isNaN(d.getTime())) return "‚Äì";
    return d.toLocaleString();
  }
  function safeHasJson(key){
    const s = (localStorage.getItem(key) || "").trim();
    if(!s) return false;
    if(!s.startsWith("{")) return false;
    try { JSON.parse(s); return true; } catch(e) { return false; }
  }

  function validateStorageContract(){
  // Bulletproof checks for canonical sheet keys.

  function checkOne(storageKey, canon, label){
    const raw = (localStorage.getItem(storageKey) || "").trim();
    if(!raw) return { ok:true, msg:"" };
    try{
      const obj = JSON.parse(raw);
      const has = !!obj?.sheets?.[canon];
      if(!has){
        const keys = obj?.sheets ? Object.keys(obj.sheets) : [];
        return {
          ok:false,
          msg:`‚ö†Ô∏è Contract warning: ${label} JSON exists, but sheets["${canon}"] is missing. Found sheet keys: ${keys.length ? keys.join(", ") : "(none)"}`
        };
      }
      return { ok:true, msg:"" };
    }catch{
      return { ok:false, msg:`‚ö†Ô∏è Contract warning: ${label} JSON in localStorage is invalid JSON.` };
    }
  }

  const checks = [
    checkOne(MASTER_GROW_KEY, CANON_GROW_SHEET, "Grow"),
    checkOne(MASTER_PACK_KEY, CANON_PACK_SHEET, "Pack"),
    checkOne(MASTER_EXP_KEY,  CANON_EXP_SHEET,  "Experiments"),
    checkOne(MASTER_PROC_KEY, CANON_PROC_SHEET, "Procurement"),
  ];

  const bad = checks.find(x => !x.ok);
  return bad || { ok:true, msg:"" };
}

function refreshBadges(){
  const hasGrow = safeHasJson(MASTER_GROW_KEY);
  const hasPack = safeHasJson(MASTER_PACK_KEY);
  const hasExp  = safeHasJson(MASTER_EXP_KEY);
  const hasProc = safeHasJson(MASTER_PROC_KEY);

  setTag(growTag, hasGrow);
  setTag(packTag, hasPack);
  setTag(expTag,  hasExp);
  setTag(procTag, hasProc);

  growUpdated.textContent = fmtTs(localStorage.getItem(MASTER_GROW_PING));
  packUpdated.textContent = fmtTs(localStorage.getItem(MASTER_PACK_PING));
  expUpdated.textContent  = fmtTs(localStorage.getItem(MASTER_EXP_PING));
  procUpdated.textContent = fmtTs(localStorage.getItem(MASTER_PROC_PING));

  const v = validateStorageContract();
  showContractWarning(v.ok ? "" : v.msg);
}

// =========================================================
// PREVIEW (safe)
// =========================================================
  function escapeHtml(s){
    return String(s)
      .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
      .replaceAll('"',"&quot;").replaceAll("'","&#39;");
  }

  function previewRows(rows, label){
    if(!rows || !rows.length){
      previewEl.innerHTML = `<div class="small" style="padding:10px;">No data.</div>`;
      return;
    }
    const head = rows.slice(0, 31);
    const maxCols = Math.max(...head.map(r => r?.length || 0), 1);

    let html = `<div class="small" style="padding:10px;">${escapeHtml(label || "Preview")}</div>`;
    html += `<table><thead><tr>`;
    for(let c=0;c<maxCols;c++){
      html += `<th>${escapeHtml(String(head[0]?.[c] ?? ""))}</th>`;
    }
    html += `</tr></thead><tbody>`;
    for(const r of head.slice(1)){
      html += `<tr>`;
      for(let c=0;c<maxCols;c++){
        html += `<td>${escapeHtml(String(r?.[c] ?? ""))}</td>`;
      }
      html += `</tr>`;
    }
    html += `</tbody></table>`;
    previewEl.innerHTML = html;
  }

  // =========================================================
  // CSV (robust quotes)
  // =========================================================
  function parseCsvToRows(text){
    const lines = String(text||"")
      .replace(/\r\n/g,"\n")
      .replace(/\r/g,"\n")
      .split("\n")
      .filter(l => l.trim().length);

    const rows = [];
    for(const line of lines){
      const delim = line.includes("\t") ? "\t" : ",";
      const out = [];
      let cur = "", inQ = false;

      for(let i=0;i<line.length;i++){
        const ch = line[i];
        if(ch === '"'){
          if(inQ && line[i+1] === '"'){ cur += '"'; i++; }
          else inQ = !inQ;
        } else if(!inQ && ch === delim){
          out.push(cur); cur = "";
        } else {
          cur += ch;
        }
      }
      out.push(cur);
      rows.push(out.map(v => String(v ?? "").trim()));
    }
    return rows;
  }

  // =========================================================
  // MATRIX -> {headers, rows} (preserve exact header text)
  // =========================================================
  function rowsToHeaderRows(matrix){
    const headers = (matrix?.[0] || []).map(h => String(h ?? "").trim());
    const rows = (matrix || []).slice(1).map(r => Array.isArray(r) ? r.map(v => (v === undefined ? "" : v)) : []);
    return { headers, rows };
  }

  function sheetToHeaderRows(ws){
    // raw:false gives formatted strings; that‚Äôs fine and consistent for dashboards
    const matrix = XLSX.utils.sheet_to_json(ws, { header: 1, raw: false, blankrows: false });
    return rowsToHeaderRows(matrix);
  }

  // =========================================================
  // PAYLOAD BUILDER (bulletproof canonical sheet keys)
  // =========================================================
  function buildPayloadSingleCanonical(canonicalSheetName, headerRows, meta){
    return {
      version: "v1",
      updatedAt: new Date().toISOString(),
      kind: meta?.kind || "master",
      sourceLabel: meta?.sourceLabel || "",
      // *** CRITICAL: canonical keys only ***
      sheets: { [canonicalSheetName]: headerRows }
    };
  }

  function isNonEmptySheet(hr){
    const hasAnyHeader = (hr?.headers || []).some(h => String(h||"").trim().length);
    const hasAnyRow = (hr?.rows || []).some(r => Array.isArray(r) && r.some(v => String(v ?? "").trim().length));
    return !!(hasAnyHeader && hasAnyRow);
  }

  // =========================================================
  // SAVE (overwrite) with contract guarantees + update signals
  // =========================================================
  function saveSource(which, payload, sourceLabel){
  const now = String(Date.now());
  try{
    if(which === "grow"){
      if (!payload?.sheets?.[CANON_GROW_SHEET]) throw new Error(`Grow payload missing sheets["${CANON_GROW_SHEET}"]`);
      localStorage.setItem(MASTER_GROW_KEY, JSON.stringify(payload));
      localStorage.setItem(MASTER_GROW_PING, now);
      emit(MSG_GROW, MASTER_GROW_KEY);
      setStatus(`Saved Master Grow (JSON overwritten): ${sourceLabel}`);
    } else if(which === "pack"){
      if (!payload?.sheets?.[CANON_PACK_SHEET]) throw new Error(`Pack payload missing sheets["${CANON_PACK_SHEET}"]`);
      localStorage.setItem(MASTER_PACK_KEY, JSON.stringify(payload));
      localStorage.setItem(MASTER_PACK_PING, now);
      emit(MSG_PACK, MASTER_PACK_KEY);
      setStatus(`Saved Master Pack (JSON overwritten): ${sourceLabel}`);
    } else if(which === "exp"){
      if (!payload?.sheets?.[CANON_EXP_SHEET]) throw new Error(`Experiments payload missing sheets["${CANON_EXP_SHEET}"]`);
      localStorage.setItem(MASTER_EXP_KEY, JSON.stringify(payload));
      localStorage.setItem(MASTER_EXP_PING, now);
      emit(MSG_EXP, MASTER_EXP_KEY);
      setStatus(`Saved Current Experiments (JSON overwritten): ${sourceLabel}`);
    } else if(which === "proc"){
      if (!payload?.sheets?.[CANON_PROC_SHEET]) throw new Error(`Procurement payload missing sheets["${CANON_PROC_SHEET}"]`);
      localStorage.setItem(MASTER_PROC_KEY, JSON.stringify(payload));
      localStorage.setItem(MASTER_PROC_PING, now);
      emit(MSG_PROC, MASTER_PROC_KEY);
      setStatus(`Saved Procurement (JSON overwritten): ${sourceLabel}`);
    }
  }catch(e){
    console.warn("Save failed:", e);
    setStatus("Failed to write to localStorage (blocked/full) or payload contract violated.");
  }
  refreshBadges();
}

// =========================================================
// EXCEL SHEET PICKING (tolerant)
// =========================================================
  function pickSheetByName(wb, candidates){
    const names = wb?.SheetNames || [];
    const want = (candidates||[]).map(norm);

    // exact
    for(const n of names) if(want.includes(norm(n))) return n;

    // substring
    for(const n of names){
      const nn = norm(n);
      if(want.some(w => nn.includes(w))) return n;
    }
    return null;
  }

  function pickFallbackSheet(wb){
    const names = wb?.SheetNames || [];
    return names.length ? names[0] : null;
  }

  // =========================================================
  // FILE HANDLING
  // =========================================================
  let lastCsvMatrix = null;
  let lastCsvName = "";

  async function handleFile(file){
    if(!file) return;

    assignGrowBtn.disabled = true;
    assignPackBtn.disabled = true;
    assignExpBtn.disabled = true;
    assignProcBtn.disabled = true;
    lastCsvMatrix = null;
    lastCsvName = "";

    fileMeta.textContent = `Last file: ${file.name}`;
    showContractWarning("");

    const lower = norm(file.name);
    const isCsv = lower.endsWith(".csv");

    // -------------------------
    // CSV
    // -------------------------
    if(isCsv){
      setStatus("Reading CSV‚Ä¶");
      const text = await file.text();
      const rows = parseCsvToRows(text);
      lastCsvMatrix = rows;
      lastCsvName = file.name;

      previewRows(rows, `Preview CSV: ${file.name}`);
      // Allow manual assignment after any CSV load
      assignGrowBtn.disabled = false;
      assignPackBtn.disabled = false;
      assignExpBtn.disabled = false;
      assignProcBtn.disabled = false;

      // Auto-assign
if(lower.includes("grow")){
  const hr = rowsToHeaderRows(rows);
  const payload = buildPayloadSingleCanonical(CANON_GROW_SHEET, hr, { kind: "grow", sourceLabel: `CSV: ${file.name}` });
  saveSource("grow", payload, `CSV: ${file.name}`);
  setStatus("CSV loaded and auto-assigned to Master Grow. You can reassign with the buttons.");
}
else if(lower.includes("pack")){
  const hr = rowsToHeaderRows(rows);
  const payload = buildPayloadSingleCanonical(CANON_PACK_SHEET, hr, { kind: "pack", sourceLabel: `CSV: ${file.name}` });
  saveSource("pack", payload, `CSV: ${file.name}`);
  setStatus("CSV loaded and auto-assigned to Master Pack. You can reassign with the buttons.");
}
else if(lower.includes("experiment") || lower.includes("experiments") || lower.includes("exp")){
  const hr = rowsToHeaderRows(rows);
  const payload = buildPayloadSingleCanonical(CANON_EXP_SHEET, hr, { kind: "exp", sourceLabel: `CSV: ${file.name}` });
  saveSource("exp", payload, `CSV: ${file.name}`);
  setStatus("CSV loaded and auto-assigned to Current Experiments. You can reassign with the buttons.");
} else if(lower.includes("procure") || lower.includes("procurement") || lower.includes("purch")){
  const hr = rowsToHeaderRows(rows);
  const payload = buildPayloadSingleCanonical(CANON_PROC_SHEET, hr, { kind: "proc", sourceLabel: `CSV: ${file.name}` });
  saveSource("proc", payload, `CSV: ${file.name}`);
  setStatus("CSV loaded and auto-assigned to Procurement. You can reassign with the buttons.");
} else {
        setStatus("CSV loaded. Assign it to Master Grow, Master Pack, Experiments, or Procurement.");
      }
      return;
    }

    // -------------------------
    // Excel
    // -------------------------
    setStatus("Reading Excel‚Ä¶");
    const buf = await file.arrayBuffer();
    const wb = XLSX.read(buf, { type:"array" });
    const names = wb.SheetNames || [];

    // Tolerant picks
    const growSheet = pickSheetByName(wb, ["master grow","master_grow","grow","mg","01","1"]);
    const packSheet = pickSheetByName(wb, ["master pack","master_pack","pack","mp","04","4"]);
const expSheet  = pickSheetByName(wb, ["current experiments","experiments","experiment","exp"]);
const procSheet = pickSheetByName(wb, ["procurement","procure","purchasing","purchase","vendor","supplies"]);

let wroteAny = false;

    // Grow
    if(growSheet){
      const hr = sheetToHeaderRows(wb.Sheets[growSheet]);
      if(isNonEmptySheet(hr)){
        // *** CRITICAL FIX: ALWAYS SAVE UNDER "Master Grow" ***
        const payload = buildPayloadSingleCanonical(CANON_GROW_SHEET, hr, { kind: "grow", sourceLabel: `XLSX sheet: ${growSheet}` });
        saveSource("grow", payload, `XLSX sheet: ${growSheet}`);
        wroteAny = true;
      } else {
        setStatus(`Found sheet "${growSheet}" but it was empty (did not overwrite Master Grow).`);
      }
    }

    // Pack
    if(packSheet){
      const hr = sheetToHeaderRows(wb.Sheets[packSheet]);
      if(isNonEmptySheet(hr)){
        // *** ALWAYS SAVE UNDER "Master Pack" ***
        const payload = buildPayloadSingleCanonical(CANON_PACK_SHEET, hr, { kind: "pack", sourceLabel: `XLSX sheet: ${packSheet}` });
        saveSource("pack", payload, `XLSX sheet: ${packSheet}`);
        wroteAny = true;
      } else {
        setStatus(`Found sheet "${packSheet}" but it was empty (did not overwrite Master Pack).`);
      }
    }

// Experiments
if(expSheet){
  const hr = sheetToHeaderRows(wb.Sheets[expSheet]);
  if(isNonEmptySheet(hr)){
    const payload = buildPayloadSingleCanonical(CANON_EXP_SHEET, hr, { kind: "exp", sourceLabel: `XLSX sheet: ${expSheet}` });
    saveSource("exp", payload, `XLSX sheet: ${expSheet}`);
    wroteAny = true;
  } else {
    setStatus(`Found sheet "${expSheet}" but it was empty (did not overwrite Experiments).`);
  }
}

// Procurement
if(procSheet){
  const hr = sheetToHeaderRows(wb.Sheets[procSheet]);
  if(isNonEmptySheet(hr)){
    const payload = buildPayloadSingleCanonical(CANON_PROC_SHEET, hr, { kind: "proc", sourceLabel: `XLSX sheet: ${procSheet}` });
    saveSource("proc", payload, `XLSX sheet: ${procSheet}`);
    wroteAny = true;
  } else {
    setStatus(`Found sheet "${procSheet}" but it was empty (did not overwrite Procurement).`);
  }
}

// Preview: whichever is present, otherwise first sheet
    const previewName = growSheet || packSheet || expSheet || procSheet || pickFallbackSheet(wb);
    if(previewName){
      const ws = wb.Sheets[previewName];
      const rows = XLSX.utils.sheet_to_json(ws, { header: 1, blankrows:false, raw:false });
      previewRows(rows, `Preview XLSX: ${previewName}`);
    } else {
      previewEl.innerHTML = `<div class="small" style="padding:10px;">No sheets found.</div>`;
    }

    if(!wroteAny){
      setStatus("Excel loaded, but Master Grow/Master Pack sheets were not found (no overwrite performed).");
      // Add a helpful warning about canonical keys
      showContractWarning(
        `Tip: Your dashboards require the canonical keys: sheets["${CANON_GROW_SHEET}"] and sheets["${CANON_PACK_SHEET}"]. ` +
        `This tool will save canonically only if it can identify Grow/Pack sheets in the Excel file.`
      );
    }
  }

  // =========================================================
  // DOWNLOAD JSON
  // =========================================================
  function downloadJsonFromLocalStorage(key, filename){
    const s = localStorage.getItem(key);
    if(!s) return setStatus(`Nothing stored for ${filename} yet.`);
    try { JSON.parse(s); } catch { return setStatus(`Stored JSON is invalid for ${filename}.`); }

    const blob = new Blob([s], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
    setStatus(`Downloaded ${filename}.`);
  }

  // =========================================================
  
function isObject(x){ return x && typeof x === "object" && !Array.isArray(x); }

function normalizeMasterPayload(raw, kind){
  // Ensures canonical sheet keys exist so dashboards never break.
  const want =
    (kind === "grow") ? CANON_GROW_SHEET :
    (kind === "pack") ? CANON_PACK_SHEET :
    (kind === "exp")  ? CANON_EXP_SHEET  :
    CANON_PROC_SHEET;

  if (!isObject(raw)) return raw;

  if (isObject(raw.sheets) && raw.sheets[want]) return raw;

  if (isObject(raw.sheets)) {
    const keys = Object.keys(raw.sheets);
    const wantLower = want.toLowerCase();

    let match = keys.find(k => String(k).trim().toLowerCase() === wantLower);
    if (!match && kind === "grow") match = keys.find(k => String(k).toLowerCase().includes("grow"));
    if (!match && kind === "pack") match = keys.find(k => String(k).toLowerCase().includes("pack"));
    if (!match && kind === "exp")  match = keys.find(k => String(k).toLowerCase().includes("experiment"));
    if (!match && kind === "proc") match = keys.find(k => String(k).toLowerCase().includes("procure"));

    if (match) {
      const clone = JSON.parse(JSON.stringify(raw));
      clone.sheets = clone.sheets || {};
      clone.sheets[want] = clone.sheets[match];
      return clone;
    }
  }

  if (Array.isArray(raw.headers) && Array.isArray(raw.rows)) {
    return {
      version: raw.version || "v1",
      updatedAt: raw.updatedAt || new Date().toISOString(),
      kind: raw.kind || kind,
      sourceLabel: raw.sourceLabel || "worker",
      sheets: { [want]: { headers: raw.headers, rows: raw.rows } }
    };
  }

  return raw;
}

// WORKER HELPERS
  // =========================================================
  async function workerGetJson(url){
    const bust = url + (url.includes("?") ? "&" : "?") + "ts=" + Date.now();
    const res = await fetch(bust, { method:"GET", cache:"no-store" });
    const text = await res.text();
    if(!res.ok) throw new Error(text || `HTTP ${res.status}`);
    try { return JSON.parse(text); }
    catch { throw new Error("Worker returned non-JSON."); }
  }

  async function pullFromSupabase(){
  pullBtn.disabled = true;
  setStatus("Pulling from Supabase (via Worker)‚Ä¶");
  showContractWarning("");

  try { await fetch(WORKER_HEALTH_URL, { cache:"no-store" }); } catch {}

  try{
    let gotAny = false;
    const now = String(Date.now());

    try{
      const grow = normalizeMasterPayload(await workerGetJson(WORKER_GROW_URL), "grow");
      localStorage.setItem(MASTER_GROW_KEY, JSON.stringify(grow));
      localStorage.setItem(MASTER_GROW_PING, now);
      emit(MSG_GROW, MASTER_GROW_KEY);
      gotAny = true;
    }catch(e){ console.warn("Grow pull failed:", e); }

    try{
      const pack = normalizeMasterPayload(await workerGetJson(WORKER_PACK_URL), "pack");
      localStorage.setItem(MASTER_PACK_KEY, JSON.stringify(pack));
      localStorage.setItem(MASTER_PACK_PING, now);
      emit(MSG_PACK, MASTER_PACK_KEY);
      gotAny = true;
    }catch(e){ console.warn("Pack pull failed:", e); }

    try{
      const exp = normalizeMasterPayload(await workerGetJson(WORKER_EXP_URL), "exp");
      localStorage.setItem(MASTER_EXP_KEY, JSON.stringify(exp));
      localStorage.setItem(MASTER_EXP_PING, now);
      emit(MSG_EXP, MASTER_EXP_KEY);
      gotAny = true;
    }catch(e){ console.warn("Experiments pull failed:", e); }

    try{
      const proc = normalizeMasterPayload(await workerGetJson(WORKER_PROC_URL), "proc");
      localStorage.setItem(MASTER_PROC_KEY, JSON.stringify(proc));
      localStorage.setItem(MASTER_PROC_PING, now);
      emit(MSG_PROC, MASTER_PROC_KEY);
      gotAny = true;
    }catch(e){ console.warn("Procurement pull failed:", e); }

    refreshBadges();

    if(gotAny) setStatus("‚úÖ Pulled latest JSON into localStorage.");
    else setStatus("‚ö†Ô∏è Nothing pulled. (Worker returned errors / files missing.)");

    const v = validateStorageContract();
    if (!v.ok) showContractWarning(v.msg);
  }catch(err){
    console.error(err);
    setStatus(`‚ùå Pull failed: ${err.message}`);
  }finally{
    pullBtn.disabled = false;
  }
}

async function publishToSupabase(){
    const growStr = localStorage.getItem(MASTER_GROW_KEY);
    const packStr = localStorage.getItem(MASTER_PACK_KEY);
    const expStr  = localStorage.getItem(MASTER_EXP_KEY);
    const procStr = localStorage.getItem(MASTER_PROC_KEY);

    if(!growStr && !packStr && !expStr && !procStr){
      setStatus("Nothing to publish yet. Upload files first.");
      return;
    }

    // validate JSON early
    try { if(growStr) JSON.parse(growStr); } catch { return setStatus("Grow JSON is invalid (cannot publish)."); }
    try { if(packStr) JSON.parse(packStr); } catch { return setStatus("Pack JSON is invalid (cannot publish)."); }
    try { if(expStr)  JSON.parse(expStr);  } catch { return setStatus("Experiments JSON is invalid (cannot publish)."); }
    try { if(procStr) JSON.parse(procStr); } catch { return setStatus("Procurement JSON is invalid (cannot publish)."); }

    // Contract check (warn but allow publish if you want)
    const v = validateStorageContract();
    if (!v.ok) showContractWarning(v.msg);

    publishBtn.disabled = true;
    setStatus("Publishing to Supabase (via Worker PUT /data/...)‚Ä¶");

    try{
      const results = [];

      if(growStr){
        const res = await fetch(WORKER_GROW_URL, {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: growStr
        });
        const text = await res.text().catch(() => "");
        if(!res.ok) throw new Error(`Grow publish failed (${res.status}): ${text}`);
        results.push("grow.json");
      }

      if(packStr){
        const res = await fetch(WORKER_PACK_URL, {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: packStr
        });
        const text = await res.text().catch(() => "");
        if(!res.ok) throw new Error(`Pack publish failed (${res.status}): ${text}`);
        results.push("pack.json");
      }

      if(expStr){
        const res = await fetch(WORKER_EXP_URL, {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: expStr
        });
        const text = await res.text().catch(() => "");
        if(!res.ok) throw new Error(`Experiments publish failed (${res.status}): ${text}`);
        results.push("experiments.json");
      }

      if(procStr){
        const res = await fetch(WORKER_PROC_URL, {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: procStr
        });
        const text = await res.text().catch(() => "");
        if(!res.ok) throw new Error(`Procurement publish failed (${res.status}): ${text}`);
        results.push("procurement.json");
      }

      setStatus(`‚úÖ Published: ${results.join(" + ")}`);
    }catch(err){
      console.error(err);
      setStatus(`‚ùå Publish failed: ${err.message}`);
    }finally{
      publishBtn.disabled = false;
      refreshBadges();
    }
  }

  // =========================================================
  // WIRE EVENTS
  // =========================================================
  chooseBtn.addEventListener("click", () => fileInput.click());
  fileInput.addEventListener("change", (e) => handleFile(e.target.files?.[0] || null));

  assignGrowBtn.addEventListener("click", () => {
    if(!lastCsvMatrix || !lastCsvMatrix.length) return setStatus("No CSV loaded to assign.");
    const hr = rowsToHeaderRows(lastCsvMatrix);
    const payload = buildPayloadSingleCanonical(CANON_GROW_SHEET, hr, { kind: "grow", sourceLabel: `CSV (manual): ${lastCsvName}` });
    saveSource("grow", payload, `CSV (manual): ${lastCsvName}`);
    assignGrowBtn.disabled = true;
    assignPackBtn.disabled = true;
  });

  assignPackBtn.addEventListener("click", () => {
    if(!lastCsvMatrix || !lastCsvMatrix.length) return setStatus("No CSV loaded to assign.");
    const hr = rowsToHeaderRows(lastCsvMatrix);
    const payload = buildPayloadSingleCanonical(CANON_PACK_SHEET, hr, { kind: "pack", sourceLabel: `CSV (manual): ${lastCsvName}` });
    saveSource("pack", payload, `CSV (manual): ${lastCsvName}`);
    assignGrowBtn.disabled = true;
    assignPackBtn.disabled = true;
  });

assignExpBtn.addEventListener("click", () => {
  if(!lastCsvMatrix || !lastCsvMatrix.length) return setStatus("No CSV loaded to assign.");
  const hr = rowsToHeaderRows(lastCsvMatrix);
  const payload = buildPayloadSingleCanonical(CANON_EXP_SHEET, hr, { kind: "exp", sourceLabel: `CSV (manual): ${lastCsvName}` });
  saveSource("exp", payload, `CSV (manual): ${lastCsvName}`);
  assignGrowBtn.disabled = true;
  assignPackBtn.disabled = true;
  assignExpBtn.disabled = true;
  assignProcBtn.disabled = true;
});

assignProcBtn.addEventListener("click", () => {
  if(!lastCsvMatrix || !lastCsvMatrix.length) return setStatus("No CSV loaded to assign.");
  const hr = rowsToHeaderRows(lastCsvMatrix);
  const payload = buildPayloadSingleCanonical(CANON_PROC_SHEET, hr, { kind: "proc", sourceLabel: `CSV (manual): ${lastCsvName}` });
  saveSource("proc", payload, `CSV (manual): ${lastCsvName}`);
  assignGrowBtn.disabled = true;
  assignPackBtn.disabled = true;
  assignExpBtn.disabled = true;
  assignProcBtn.disabled = true;
});

  clearBtn.addEventListener("click", () => {
    try{
      localStorage.removeItem(MASTER_GROW_KEY);
  localStorage.removeItem(MASTER_PACK_KEY);
  localStorage.removeItem(MASTER_EXP_KEY);
  localStorage.removeItem(MASTER_PROC_KEY);
  localStorage.removeItem(MASTER_GROW_PING);
  localStorage.removeItem(MASTER_PACK_PING);
  localStorage.removeItem(MASTER_EXP_PING);
  localStorage.removeItem(MASTER_PROC_PING);
    }catch(e){}

    emit(MSG_GROW, MASTER_GROW_KEY);
    emit(MSG_PACK, MASTER_PACK_KEY);
    emit(MSG_EXP, MASTER_EXP_KEY);
    emit(MSG_PROC, MASTER_PROC_KEY);

    previewEl.innerHTML = `<div class="small" style="padding:10px;">Upload a file to preview data.</div>`;
    setStatus("Cleared stored Master Grow + Master Pack.");
    showContractWarning("");
    refreshBadges();
  });

  downloadGrowBtn.addEventListener("click", () => downloadJsonFromLocalStorage(MASTER_GROW_KEY, "grow.json"));
downloadPackBtn.addEventListener("click", () => downloadJsonFromLocalStorage(MASTER_PACK_KEY, "pack.json"));
downloadExpBtn.addEventListener("click", () => downloadJsonFromLocalStorage(MASTER_EXP_KEY, "experiments.json"));
downloadProcBtn.addEventListener("click", () => downloadJsonFromLocalStorage(MASTER_PROC_KEY, "procurement.json"));

  publishBtn.addEventListener("click", publishToSupabase);
  pullBtn.addEventListener("click", pullFromSupabase);

  // Drag & drop
  ["dragenter","dragover"].forEach(evt => {
    dropzone.addEventListener(evt, (e) => {
      e.preventDefault(); e.stopPropagation();
      dropzone.classList.add("dragover");
    });
  });
  ["dragleave","drop"].forEach(evt => {
    dropzone.addEventListener(evt, (e) => {
      e.preventDefault(); e.stopPropagation();
      dropzone.classList.remove("dragover");
    });
  });
  dropzone.addEventListener("drop", (e) => {
    const file = e.dataTransfer?.files?.[0];
    handleFile(file || null);
  });

  // Keep badges fresh if something else updates localStorage
  window.addEventListener("storage", (e) => {
    if (!e) return;
    if ([MASTER_GROW_KEY, MASTER_PACK_KEY, MASTER_EXP_KEY, MASTER_PROC_KEY, MASTER_GROW_PING, MASTER_PACK_PING, MASTER_EXP_PING, MASTER_PROC_PING].includes(e.key)) {
      refreshBadges();
    }
  });

  // =========================================================
  // INIT
  // =========================================================
  refreshBadges();
  setStatus("Waiting for file‚Ä¶");
</script>
</body>
</html>
