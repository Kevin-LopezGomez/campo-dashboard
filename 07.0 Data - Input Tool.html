<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Data Input ‚Äì Grow / Pack / Experiments / Procurement / Store Visit</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- SheetJS (Excel reader) -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <style>
    :root{
      --bg:#020617;
      --panel:#0b1222;
      --border:#1f2937;
      --text:#e5e7eb;
      --sub:#9ca3af;
      --accent:#22c55e;
      --danger:#ef4444;
      --warn:#f59e0b;
    }
    *{box-sizing:border-box;}
    body{
      margin:0;
      font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
      background: radial-gradient(circle at top, #111827 0, #020617 55%, #000 100%);
      color:var(--text);
    }
    .wrap{max-width:1200px;margin:20px auto;padding:16px;}
    h1{margin:0;font-size:1.2rem;}
    p{color:var(--sub);font-size:.85rem;line-height:1.35;margin:.4rem 0 0;}
    .panel{
      background: radial-gradient(circle at top left, rgba(15,23,42,.94), rgba(15,23,42,.98));
      border:1px solid rgba(55,65,81,.9);
      border-radius:16px;
      padding:16px;
      margin-top:16px;
      box-shadow: 0 18px 40px rgba(0,0,0,.55);
    }
    .row{display:grid;grid-template-columns:1.4fr 1fr;gap:16px;}
    @media(max-width:900px){.row{grid-template-columns:1fr;}}
    .drop{
      border:1px dashed rgba(148,163,184,.45);
      border-radius:14px;
      padding:18px;
      min-height:170px;
      display:flex;
      flex-direction:column;
      justify-content:center;
      gap:10px;
      background: rgba(2,6,23,.25);
    }
    .drop.dragover{border-color: rgba(34,197,94,.8);background: rgba(34,197,94,.08);}
    .btnrow{display:flex;flex-wrap:wrap;gap:8px;}
    .btnrow.topActions{
      display:grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap:8px;
      align-items:stretch;
    }
    .btnrow.topActions button{
      width:100%;
      justify-content:center;
      white-space:nowrap;
      min-width:0;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    @media(max-width:1100px){
      .btnrow.topActions{ grid-template-columns: repeat(2, minmax(0, 1fr)); }
    }
    @media(max-width:640px){
      .btnrow.topActions{ grid-template-columns: 1fr; }
    }
    button{
      background: rgba(15,23,42,.95);
      border:1px solid rgba(55,65,81,.9);
      color:var(--text);
      border-radius:999px;
      padding:7px 12px;
      cursor:pointer;
      font-size:.8rem;
      display:inline-flex;align-items:center;gap:8px;
      transition: transform .06s ease, opacity .12s ease;
    }
    button:active{transform:scale(.99);}
    button.primary{
      background: radial-gradient(circle at 0 0, rgba(34,197,94,.28), rgba(22,163,74,.95));
      border-color: rgba(34,197,94,.9);
      box-shadow: 0 9px 26px rgba(16,185,129,.20);
    }
    button.danger{
      background: radial-gradient(circle at 0 0, rgba(239,68,68,.20), rgba(127,29,29,.85));
      border-color: rgba(239,68,68,.75);
    }
    button.info{
      background: radial-gradient(circle at 0 0, rgba(56,189,248,.25), rgba(3,105,161,.9));
      border-color: rgba(56,189,248,.8);
      box-shadow: 0 9px 24px rgba(2,132,199,.2);
    }
    button.ghost{
      background: rgba(2,6,23,.35);
      border-color: rgba(55,65,81,.75);
    }
    button[disabled]{opacity:.45;cursor:not-allowed;}

    .meta{
      border:1px solid rgba(31,41,55,.85);
      border-radius:14px;
      padding:12px;
      background: rgba(2,6,23,.25);
      display:grid;
      gap:10px;
    }
    .kv{display:flex;justify-content:space-between;gap:10px;color:var(--sub);font-size:.82rem;}
    .kv b{color:var(--text);}
    .kvRight{display:inline-flex;align-items:center;gap:8px;}
    .iconBtn{
      background: rgba(2,6,23,.35);
      border:1px solid rgba(55,65,81,.75);
      color:var(--text);
      border-radius:999px;
      padding:2px 8px;
      font-size:.72rem;
      line-height:1.2;
      min-height:24px;
    }
    .iconBtn:disabled{
      opacity:.4;
      cursor:not-allowed;
    }
    .tag{
      border:1px solid rgba(148,163,184,.25);
      border-radius:999px;
      padding:2px 8px;
      font-size:.72rem;
      background: rgba(2,6,23,.35);
      color:var(--sub);
      display:inline-flex;align-items:center;gap:6px;
      white-space:nowrap;
    }
    .dot{width:7px;height:7px;border-radius:999px;background:var(--accent);box-shadow:0 0 0 3px rgba(34,197,94,.2);}
    .dot.bad{background:var(--danger);box-shadow:0 0 0 3px rgba(239,68,68,.16);}
    .small{font-size:.76rem;color:var(--sub);line-height:1.35;}
    .preview{
      max-height:340px;
      overflow:auto;
      border:1px solid rgba(31,41,55,.85);
      border-radius:12px;
      margin-top:12px;
      background: rgba(2,6,23,.20);
    }
    table{width:100%;border-collapse:collapse;font-size:.75rem;min-width:900px;}
    th,td{padding:6px 10px;border-bottom:1px solid rgba(31,41,55,.75);white-space:nowrap;}
    th{color:var(--sub);text-transform:uppercase;font-size:.7rem;letter-spacing:.12em;position:sticky;top:0;background: rgba(2,6,23,.85);}

    .hint{
      margin-top:8px;
      padding:10px 12px;
      border:1px solid rgba(55,65,81,.75);
      border-radius:12px;
      background: rgba(2,6,23,.28);
      overflow-wrap:anywhere;
      word-break:break-word;
    }
    .hint code{
      white-space:normal;
      overflow-wrap:anywhere;
      word-break:break-word;
    }
    .wizard{
      margin-top:10px;
      padding:10px 12px;
      border:1px solid rgba(34,197,94,.45);
      border-radius:12px;
      background: rgba(16,185,129,.08);
      display:none;
      gap:8px;
    }
    .wizardTitle{
      font-size:.92rem;
      font-weight:800;
      color:#e2fbe9;
      letter-spacing:.01em;
    }
    .wizardDetect{
      font-size:.84rem;
      line-height:1.4;
      color:#dbeafe;
      font-weight:600;
      background: rgba(2,6,23,.35);
      border:1px solid rgba(59,130,246,.35);
      border-radius:10px;
      padding:8px 10px;
    }
    .wizardLabel{
      font-size:.82rem;
      font-weight:800;
      color:#e5e7eb;
      letter-spacing:.01em;
    }
    .wizardRow{
      display:flex;
      flex-wrap:wrap;
      align-items:center;
      gap:8px;
    }
    .wizard select{
      background: rgba(2,6,23,.6);
      color: var(--text);
      border:1px solid rgba(55,65,81,.9);
      border-radius:10px;
      padding:6px 8px;
      font-size:.8rem;
    }
    .wizList{
      margin:0;
      padding-left:16px;
      color:var(--sub);
      font-size:.78rem;
    }
    .wizList li{
      margin:6px 0;
      display:flex;
      flex-wrap:wrap;
      align-items:center;
      gap:8px;
      color:var(--sub);
    }
    .wizList .wsel{
      background: rgba(2,6,23,.6);
      color: var(--text);
      border:1px solid rgba(55,65,81,.9);
      border-radius:10px;
      padding:4px 6px;
      font-size:.76rem;
    }
    .flag{
      border:1px solid rgba(59,130,246,.45);
      border-radius:12px;
      background: rgba(30,58,138,.18);
      color:#bfdbfe;
      padding:8px 10px;
      font-size:.76rem;
      line-height:1.35;
    }
    code{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;font-size:.78rem;color:#c7d2fe;}
    .warnline{color:#fbbf24;}
  </style>
</head>

<body>
<div class="wrap">
  <h1>Data Input ‚Äì Grow / Pack / Experiments / Procurement / Store Visit</h1>
  <p>
    Supported: <b>1 XLSX</b> (multiple sheets) or <b>separate CSVs</b> for <b>Grow</b>, <b>Pack</b>, <b>Current Experiments</b>, <b>Procurement</b>, and <b>Store Visit</b>. Uploading a new file will <b>overwrite</b> only that dataset‚Äôs stored JSON.
  </p>

  <div class="panel">
    <div class="row">
      <div class="drop" id="dropzone">
        <strong>Drop .xlsx or .csv here</strong>
        <span class="small">Upload, review detected destination, then confirm assignment in the wizard before save.</span>

        <input id="fileInput" type="file" accept=".xlsx,.xls,.csv,text/csv" hidden />

        <div class="btnrow topActions">
          <button class="primary" id="chooseBtn" type="button">üìÑ Choose File</button>
          <button class="primary" id="publishBtn" type="button">üöÄ Publish to Supabase</button>
          <button class="info" id="pullBtn" type="button">‚¨áÔ∏è Pull from Supabase</button>
          <button class="danger" id="clearBtn" type="button">‚úï Clear Stored Sources</button>
        </div>

        <div class="wizard" id="importWizard">
          <div class="wizardTitle"><b>Import Wizard</b></div>
          <div class="wizardDetect" id="wizDetect">No staged upload.</div>
          <div class="wizardRow" id="wizCsvRow">
            <label class="wizardLabel" for="wizTarget">Assign to:</label>
            <select id="wizTarget">
              <option value="">Select dataset</option>
              <option value="grow">Master Grow</option>
              <option value="pack">Master Pack</option>
              <option value="exp">Current Experiments</option>
              <option value="proc">Procurement</option>
              <option value="store">Store Visit</option>
            </select>
            <button class="primary" id="wizConfirmCsvBtn" type="button">‚úÖ Confirm CSV Assignment</button>
            <button class="ghost" id="wizCancelBtn" type="button">Cancel</button>
          </div>
          <div id="wizXlsxRow" style="display:none;">
            <ul class="wizList" id="wizXlsxList"></ul>
            <div class="wizardRow">
              <button class="primary" id="wizConfirmXlsxBtn" type="button">‚úÖ Confirm XLSX Assignments</button>
              <button class="ghost" id="wizCancelBtn2" type="button">Cancel</button>
            </div>
          </div>
        </div>

        <div class="hint small">
          <b>Bulletproof contract:</b> this tool always saves Excel/CSV into:
          <br>
          <code>payload.sheets["Master Grow"]</code>, <code>payload.sheets["Master Pack"]</code>, <code>payload.sheets["Current Experiments"]</code>, <code>payload.sheets["Procurement"]</code>, and <code>payload.sheets["Store Visit"]</code>
          <br><br>
          Uploads save JSON into <code>localStorage</code> so dashboards read immediately.
          ‚ÄúPublish / Pull‚Äù uses your Cloudflare Worker as the Supabase gateway.
          <br><br>
          Worker endpoints:
          <code>GET /data/master/grow.json</code>, <code>GET /data/master/pack.json</code>, <code>GET /data/master/experiments.json</code>, <code>GET /data/master/procurement.json</code>, <code>GET /data/master/Store%20Visits.json</code>,
          <br>
          <code>PUT /data/master/grow.json</code>, <code>PUT /data/master/pack.json</code>, <code>PUT /data/master/experiments.json</code>, <code>PUT /data/master/procurement.json</code>, <code>PUT /data/master/Store%20Visits.json</code>.
        </div>

        <div id="status" class="small">Waiting for file‚Ä¶</div>
        <div id="contractWarn" class="small warnline" style="display:none;"></div>
      </div>

      <div class="meta">
        <div class="kv"><span>Master Grow</span><span class="kvRight"><button class="iconBtn" id="growDlBtn" type="button" title="Download grow.json" disabled>‚¨á</button><span class="tag" id="growTag"><span class="dot bad"></span>Missing</span></span></div>
        <div class="kv"><span>Master Pack</span><span class="kvRight"><button class="iconBtn" id="packDlBtn" type="button" title="Download pack.json" disabled>‚¨á</button><span class="tag" id="packTag"><span class="dot bad"></span>Missing</span></span></div>
        <div class="kv"><span>Current Experiments</span><span class="kvRight"><button class="iconBtn" id="expDlBtn" type="button" title="Download experiments.json" disabled>‚¨á</button><span class="tag" id="expTag"><span class="dot bad"></span>Missing</span></span></div>
        <div class="kv"><span>Procurement</span><span class="kvRight"><button class="iconBtn" id="procDlBtn" type="button" title="Download procurement.json" disabled>‚¨á</button><span class="tag" id="procTag"><span class="dot bad"></span>Missing</span></span></div>
        <div class="kv"><span>Store Visit</span><span class="kvRight"><button class="iconBtn" id="storeDlBtn" type="button" title="Download store-visit.json" disabled>‚¨á</button><span class="tag" id="storeTag"><span class="dot bad"></span>Missing</span></span></div>
        <div class="kv"><span>Grow updated</span><b id="growUpdated">‚Äì</b></div>
        <div class="kv"><span>Pack updated</span><b id="packUpdated">‚Äì</b></div>
        <div class="kv"><span>Experiments updated</span><b id="expUpdated">‚Äì</b></div>
        <div class="kv"><span>Procurement updated</span><b id="procUpdated">‚Äì</b></div>
        <div class="kv"><span>Store Visit updated</span><b id="storeUpdated">‚Äì</b></div>
        <div class="flag" id="lastAssignFlag">Last assigned upload: none</div>
        <div class="small" id="fileMeta">Last file: ‚Äì</div>
      </div>
    </div>

    <div class="preview" id="preview">
      <div class="small" style="padding:10px;">Upload a file to preview data.</div>
    </div>
  </div>
</div>

<script>
  // =========================================================
  // CONFIG
// =========================================================
const WORKER_BASE = "https://campo-publisher.kevin-lopezgomez.workers.dev";
const WORKER_HEALTH_URL = `${WORKER_BASE}/health`;
const WORKER_GROW_URL = `${WORKER_BASE}/data/master/grow.json`;
const WORKER_PACK_URL = `${WORKER_BASE}/data/master/pack.json`;
const WORKER_EXP_URL  = `${WORKER_BASE}/data/master/experiments.json`;
const WORKER_PROC_URL = `${WORKER_BASE}/data/master/procurement.json`;
const WORKER_STORE_URL = `${WORKER_BASE}/data/master/Store%20Visits.json`;
const WORKER_STORE_GET_URL = `${WORKER_BASE}/data/master/Store%20Visits.json`;
const PUBLIC_STORE_VISIT_URL = "https://lxxysrhhmtjikzpmupqb.supabase.co/storage/v1/object/public/campo-data/master/Store%20Visits.json";


  // Storage keys (must match dashboards)
const MASTER_GROW_KEY = "campo_master_grow_v1";
const MASTER_PACK_KEY = "campo_master_pack_v1";
const MASTER_EXP_KEY  = "campo_master_experiments_v1";
const MASTER_PROC_KEY = "campo_master_procurement_v1";
const MASTER_STORE_KEY = "campo_master_store_visit_v1";
const LAST_ASSIGN_META_KEY = "campo_last_assignment_meta_v1";

const MASTER_GROW_PING = "campo_master_grow_push_ping_v1";
const MASTER_PACK_PING = "campo_master_pack_push_ping_v1";
const MASTER_EXP_PING  = "campo_master_experiments_push_ping_v1";
const MASTER_PROC_PING = "campo_master_procurement_push_ping_v1";
const MASTER_STORE_PING = "campo_master_store_visit_push_ping_v1";


  // Canonical sheet keys (contract)
const CANON_GROW_SHEET = "Master Grow";
const CANON_PACK_SHEET = "Master Pack";
const CANON_EXP_SHEET  = "Current Experiments";
const CANON_PROC_SHEET = "Procurement";
const CANON_STORE_SHEET = "Store Visit";


  // Message types
const MSG_GROW = "MASTER_GROW_UPDATED";
const MSG_PACK = "MASTER_PACK_UPDATED";
const MSG_EXP  = "EXPERIMENTS_UPDATED";
const MSG_PROC = "PROCUREMENT_UPDATED";
const MSG_STORE = "STORE_VISIT_UPDATED";


  // BroadcastChannel for same-origin pages (index + dashboards)
  const BC_NAME = "campo_updates_v1";
  const bc = (() => {
    try { return ("BroadcastChannel" in window) ? new BroadcastChannel(BC_NAME) : null; }
    catch { return null; }
  })();

  // =========================================================
  // UI REFS
  // =========================================================
const dropzone = document.getElementById("dropzone");
const fileInput = document.getElementById("fileInput");
const chooseBtn = document.getElementById("chooseBtn");
const clearBtn = document.getElementById("clearBtn");

  const publishBtn = document.getElementById("publishBtn");
  const pullBtn = document.getElementById("pullBtn");
  const statusEl = document.getElementById("status");
  const previewEl = document.getElementById("preview");
  const growTag = document.getElementById("growTag");
  const packTag = document.getElementById("packTag");
const expTag  = document.getElementById("expTag");
const procTag = document.getElementById("procTag");
const storeTag = document.getElementById("storeTag");
const growDlBtn = document.getElementById("growDlBtn");
const packDlBtn = document.getElementById("packDlBtn");
const expDlBtn  = document.getElementById("expDlBtn");
const procDlBtn = document.getElementById("procDlBtn");
const storeDlBtn = document.getElementById("storeDlBtn");
const growUpdated = document.getElementById("growUpdated");
const packUpdated = document.getElementById("packUpdated");
const expUpdated  = document.getElementById("expUpdated");
const procUpdated = document.getElementById("procUpdated");
const storeUpdated = document.getElementById("storeUpdated");
const fileMeta = document.getElementById("fileMeta");
const lastAssignFlag = document.getElementById("lastAssignFlag");
const importWizard = document.getElementById("importWizard");
const wizDetect = document.getElementById("wizDetect");
const wizTarget = document.getElementById("wizTarget");
const wizCsvRow = document.getElementById("wizCsvRow");
const wizXlsxRow = document.getElementById("wizXlsxRow");
const wizXlsxList = document.getElementById("wizXlsxList");
const wizConfirmCsvBtn = document.getElementById("wizConfirmCsvBtn");
const wizConfirmXlsxBtn = document.getElementById("wizConfirmXlsxBtn");
const wizCancelBtn = document.getElementById("wizCancelBtn");
const wizCancelBtn2 = document.getElementById("wizCancelBtn2");

  const contractWarn = document.getElementById("contractWarn");

  function setStatus(msg){ statusEl.textContent = msg; }
  function norm(s){ return String(s||"").trim().toLowerCase(); }
  const KIND_LABEL = {
    grow: "Master Grow",
    pack: "Master Pack",
    exp: "Current Experiments",
    proc: "Procurement",
    store: "Store Visit"
  };

  let stagedUpload = null;

  function showContractWarning(msg){
    if (!contractWarn) return;
    if (!msg){
      contractWarn.style.display = "none";
      contractWarn.textContent = "";
      return;
    }
    contractWarn.style.display = "block";
    contractWarn.textContent = msg;
  }

  function renderLastAssignFlag(){
    if(!lastAssignFlag) return;
    let meta = null;
    try{
      meta = JSON.parse(localStorage.getItem(LAST_ASSIGN_META_KEY) || "null");
    }catch(_e){
      meta = null;
    }
    if(!meta || !meta.when || !meta.target){
      lastAssignFlag.textContent = "Last assigned upload: none";
      return;
    }
    const ts = new Date(meta.when);
    const when = isNaN(ts.getTime()) ? meta.when : ts.toLocaleString();
    const target = KIND_LABEL[meta.target] || meta.target;
    const file = meta.fileName || "unknown file";
    lastAssignFlag.textContent = `Last assigned upload: ${file} -> ${target} (${when})`;
  }

  function setLastAssignMeta(target, sourceLabel, fileName){
    const meta = {
      target,
      sourceLabel: sourceLabel || "",
      fileName: fileName || "",
      when: new Date().toISOString()
    };
    try{ localStorage.setItem(LAST_ASSIGN_META_KEY, JSON.stringify(meta)); }catch(_e){}
    renderLastAssignFlag();
  }

  function inferFileNameFromSourceLabel(sourceLabel){
    const s = String(sourceLabel || "");
    const i = s.indexOf(": ");
    if(i >= 0 && i + 2 < s.length) return s.slice(i + 2).trim();
    return s;
  }

  function clearWizard(){
    stagedUpload = null;
    if(importWizard) importWizard.style.display = "none";
    if(wizTarget) wizTarget.value = "";
    if(wizXlsxList) wizXlsxList.innerHTML = "";
  }

  function detectCsvKind(fileName){
    const n = norm(fileName);
    if(n.includes("store") && n.includes("visit")) return { kind:"store", confidence:"high" };
    if(n.includes("procure") || n.includes("procurement") || n.includes("purch")) return { kind:"proc", confidence:"high" };
    if(n.includes("experiment") || n.includes("experiments") || n.includes("exp")) return { kind:"exp", confidence:"high" };
    if(n.includes("pack")) return { kind:"pack", confidence:"high" };
    if(n.includes("grow")) return { kind:"grow", confidence:"high" };
    return { kind:"", confidence:"low" };
  }

  function showCsvWizard(fileName){
    const detection = detectCsvKind(fileName);
    const guess = detection.kind ? (KIND_LABEL[detection.kind] || detection.kind) : "No strong guess";
    if(!importWizard) return;
    importWizard.style.display = "grid";
    wizCsvRow.style.display = "flex";
    wizXlsxRow.style.display = "none";
    wizDetect.textContent = `Detected CSV: ${fileName} | Suggested: ${guess} (${detection.confidence})`;
    wizTarget.value = detection.kind || "";
  }

  function showXlsxWizard(fileName, plans){
    if(!importWizard) return;
    importWizard.style.display = "grid";
    wizCsvRow.style.display = "none";
    wizXlsxRow.style.display = "block";
    wizDetect.textContent = `Detected XLSX: ${fileName} ¬∑ ${plans.length} dataset assignment(s) ready.`;
    wizXlsxList.innerHTML = plans.map((p, i) => {
      const opts = [
        ["grow","Master Grow"],
        ["pack","Master Pack"],
        ["exp","Current Experiments"],
        ["proc","Procurement"],
        ["store","Store Visit"]
      ].map(([val,label]) => `<option value="${val}" ${p.kind===val ? "selected" : ""}>${label}</option>`).join("");
      return `<li>
        <span>Sheet "${escapeHtml(p.sheetName)}" \u2192</span>
        <select class="wsel" data-plan-index="${i}">${opts}</select>
      </li>`;
    }).join("");
  }

  // =========================================================
  // EVENTS (bulletproof propagation)
  // =========================================================
  function emit(type, key){
    const payload = { type, key, ts: Date.now() };

    // 1) postMessage to parent (index iframe wrapper)
    try { window.parent?.postMessage?.(payload, "*"); } catch(e){}

    // 2) BroadcastChannel (same-origin only)
    try { bc?.postMessage?.(payload); } catch(e){}

    // 3) CustomEvent in this frame (some dashboards listen)
    try { window.dispatchEvent(new CustomEvent(type, { detail: payload })); } catch(e){}
    try { document.dispatchEvent(new CustomEvent(type, { detail: payload })); } catch(e){}
  }

  // =========================================================
  // BADGES
  // =========================================================
  function setTag(el, ok){
    el.innerHTML = ok
      ? `<span class="dot"></span>Loaded`
      : `<span class="dot bad"></span>Missing`;
  }
  function fmtTs(ts){
    if(!ts) return "‚Äì";
    const d = new Date(Number(ts));
    if(isNaN(d.getTime())) return "‚Äì";
    return d.toLocaleString();
  }
  function safeHasJson(key){
    const s = (localStorage.getItem(key) || "").trim();
    if(!s) return false;
    if(!s.startsWith("{")) return false;
    try { JSON.parse(s); return true; } catch(e) { return false; }
  }

  function validateStorageContract(){
  // Bulletproof checks for canonical sheet keys.

  function checkOne(storageKey, canon, label){
    const raw = (localStorage.getItem(storageKey) || "").trim();
    if(!raw) return { ok:true, msg:"" };
    try{
      const obj = JSON.parse(raw);
      const has = !!obj?.sheets?.[canon];
      if(!has){
        const keys = obj?.sheets ? Object.keys(obj.sheets) : [];
        return {
          ok:false,
          msg:`‚ö†Ô∏è Contract warning: ${label} JSON exists, but sheets["${canon}"] is missing. Found sheet keys: ${keys.length ? keys.join(", ") : "(none)"}`
        };
      }
      return { ok:true, msg:"" };
    }catch{
      return { ok:false, msg:`‚ö†Ô∏è Contract warning: ${label} JSON in localStorage is invalid JSON.` };
    }
  }

  const checks = [
    checkOne(MASTER_GROW_KEY, CANON_GROW_SHEET, "Grow"),
    checkOne(MASTER_PACK_KEY, CANON_PACK_SHEET, "Pack"),
    checkOne(MASTER_EXP_KEY,  CANON_EXP_SHEET,  "Experiments"),
    checkOne(MASTER_PROC_KEY, CANON_PROC_SHEET, "Procurement"),
    checkOne(MASTER_STORE_KEY, CANON_STORE_SHEET, "Store Visit"),
  ];

  const bad = checks.find(x => !x.ok);
  return bad || { ok:true, msg:"" };
}

function refreshBadges(){
  const hasGrow = safeHasJson(MASTER_GROW_KEY);
  const hasPack = safeHasJson(MASTER_PACK_KEY);
  const hasExp  = safeHasJson(MASTER_EXP_KEY);
  const hasProc = safeHasJson(MASTER_PROC_KEY);
  const hasStore = safeHasJson(MASTER_STORE_KEY);

  setTag(growTag, hasGrow);
  setTag(packTag, hasPack);
  setTag(expTag,  hasExp);
  setTag(procTag, hasProc);
  setTag(storeTag, hasStore);
  if(growDlBtn) growDlBtn.disabled = !hasGrow;
  if(packDlBtn) packDlBtn.disabled = !hasPack;
  if(expDlBtn) expDlBtn.disabled = !hasExp;
  if(procDlBtn) procDlBtn.disabled = !hasProc;
  if(storeDlBtn) storeDlBtn.disabled = !hasStore;

  growUpdated.textContent = fmtTs(localStorage.getItem(MASTER_GROW_PING));
  packUpdated.textContent = fmtTs(localStorage.getItem(MASTER_PACK_PING));
  expUpdated.textContent  = fmtTs(localStorage.getItem(MASTER_EXP_PING));
  procUpdated.textContent = fmtTs(localStorage.getItem(MASTER_PROC_PING));
  storeUpdated.textContent = fmtTs(localStorage.getItem(MASTER_STORE_PING));

  const v = validateStorageContract();
  showContractWarning(v.ok ? "" : v.msg);
  renderLastAssignFlag();
}

// =========================================================
// PREVIEW (safe)
// =========================================================
  function escapeHtml(s){
    return String(s)
      .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
      .replaceAll('"',"&quot;").replaceAll("'","&#39;");
  }

  function previewRows(rows, label){
    if(!rows || !rows.length){
      previewEl.innerHTML = `<div class="small" style="padding:10px;">No data.</div>`;
      return;
    }
    const head = rows.slice(0, 31);
    const maxCols = Math.max(...head.map(r => r?.length || 0), 1);

    let html = `<div class="small" style="padding:10px;">${escapeHtml(label || "Preview")}</div>`;
    html += `<table><thead><tr>`;
    for(let c=0;c<maxCols;c++){
      html += `<th>${escapeHtml(String(head[0]?.[c] ?? ""))}</th>`;
    }
    html += `</tr></thead><tbody>`;
    for(const r of head.slice(1)){
      html += `<tr>`;
      for(let c=0;c<maxCols;c++){
        html += `<td>${escapeHtml(String(r?.[c] ?? ""))}</td>`;
      }
      html += `</tr>`;
    }
    html += `</tbody></table>`;
    previewEl.innerHTML = html;
  }

  // =========================================================
  // CSV (robust quotes)
  // =========================================================
  function parseCsvToRows(text){
    const lines = String(text||"")
      .replace(/\r\n/g,"\n")
      .replace(/\r/g,"\n")
      .split("\n")
      .filter(l => l.trim().length);

    const rows = [];
    for(const line of lines){
      const delim = line.includes("\t") ? "\t" : ",";
      const out = [];
      let cur = "", inQ = false;

      for(let i=0;i<line.length;i++){
        const ch = line[i];
        if(ch === '"'){
          if(inQ && line[i+1] === '"'){ cur += '"'; i++; }
          else inQ = !inQ;
        } else if(!inQ && ch === delim){
          out.push(cur); cur = "";
        } else {
          cur += ch;
        }
      }
      out.push(cur);
      rows.push(out.map(v => String(v ?? "").trim()));
    }
    return rows;
  }

  // =========================================================
  // MATRIX -> {headers, rows} (preserve exact header text)
  // =========================================================
  function rowsToHeaderRows(matrix){
    const headers = (matrix?.[0] || []).map(h => String(h ?? "").trim());
    const rows = (matrix || []).slice(1).map(r => Array.isArray(r) ? r.map(v => (v === undefined ? "" : v)) : []);
    return { headers, rows };
  }

  function sheetToHeaderRows(ws){
    // raw:false gives formatted strings; that‚Äôs fine and consistent for dashboards
    const matrix = XLSX.utils.sheet_to_json(ws, { header: 1, raw: false, blankrows: false });
    return rowsToHeaderRows(matrix);
  }

  // =========================================================
  // PAYLOAD BUILDER (bulletproof canonical sheet keys)
  // =========================================================
  function buildPayloadSingleCanonical(canonicalSheetName, headerRows, meta){
    return {
      version: "v1",
      updatedAt: new Date().toISOString(),
      kind: meta?.kind || "master",
      sourceLabel: meta?.sourceLabel || "",
      // *** CRITICAL: canonical keys only ***
      sheets: { [canonicalSheetName]: headerRows }
    };
  }

  function isNonEmptySheet(hr){
    const hasAnyHeader = (hr?.headers || []).some(h => String(h||"").trim().length);
    const hasAnyRow = (hr?.rows || []).some(r => Array.isArray(r) && r.some(v => String(v ?? "").trim().length));
    return !!(hasAnyHeader && hasAnyRow);
  }

  // =========================================================
  // SAVE (overwrite) with contract guarantees + update signals
  // =========================================================
  function saveSource(which, payload, sourceLabel){
  const now = String(Date.now());
  let saved = false;
  try{
    if(which === "grow"){
      if (!payload?.sheets?.[CANON_GROW_SHEET]) throw new Error(`Grow payload missing sheets["${CANON_GROW_SHEET}"]`);
      localStorage.setItem(MASTER_GROW_KEY, JSON.stringify(payload));
      localStorage.setItem(MASTER_GROW_PING, now);
      emit(MSG_GROW, MASTER_GROW_KEY);
      saved = true;
      setStatus(`Saved Master Grow (JSON overwritten): ${sourceLabel}`);
    } else if(which === "pack"){
      if (!payload?.sheets?.[CANON_PACK_SHEET]) throw new Error(`Pack payload missing sheets["${CANON_PACK_SHEET}"]`);
      localStorage.setItem(MASTER_PACK_KEY, JSON.stringify(payload));
      localStorage.setItem(MASTER_PACK_PING, now);
      emit(MSG_PACK, MASTER_PACK_KEY);
      saved = true;
      setStatus(`Saved Master Pack (JSON overwritten): ${sourceLabel}`);
    } else if(which === "exp"){
      if (!payload?.sheets?.[CANON_EXP_SHEET]) throw new Error(`Experiments payload missing sheets["${CANON_EXP_SHEET}"]`);
      localStorage.setItem(MASTER_EXP_KEY, JSON.stringify(payload));
      localStorage.setItem(MASTER_EXP_PING, now);
      emit(MSG_EXP, MASTER_EXP_KEY);
      saved = true;
      setStatus(`Saved Current Experiments (JSON overwritten): ${sourceLabel}`);
    } else if(which === "proc"){
      if (!payload?.sheets?.[CANON_PROC_SHEET]) throw new Error(`Procurement payload missing sheets["${CANON_PROC_SHEET}"]`);
      localStorage.setItem(MASTER_PROC_KEY, JSON.stringify(payload));
      localStorage.setItem(MASTER_PROC_PING, now);
      emit(MSG_PROC, MASTER_PROC_KEY);
      saved = true;
      setStatus(`Saved Procurement (JSON overwritten): ${sourceLabel}`);
    } else if(which === "store"){
      if (!payload?.sheets?.[CANON_STORE_SHEET]) throw new Error(`Store Visit payload missing sheets["${CANON_STORE_SHEET}"]`);
      localStorage.setItem(MASTER_STORE_KEY, JSON.stringify(payload));
      localStorage.setItem(MASTER_STORE_PING, now);
      emit(MSG_STORE, MASTER_STORE_KEY);
      saved = true;
      setStatus(`Saved Store Visit (JSON overwritten): ${sourceLabel}`);
    }
  }catch(e){
    console.warn("Save failed:", e);
    setStatus("Failed to write to localStorage (blocked/full) or payload contract violated.");
  }
  if(saved) setLastAssignMeta(which, sourceLabel, lastCsvName || inferFileNameFromSourceLabel(sourceLabel));
  refreshBadges();
}

// =========================================================
// EXCEL SHEET PICKING (tolerant)
// =========================================================
  function pickSheetByName(wb, candidates){
    const names = wb?.SheetNames || [];
    const want = (candidates||[]).map(norm);

    // exact
    for(const n of names) if(want.includes(norm(n))) return n;

    // substring
    for(const n of names){
      const nn = norm(n);
      if(want.some(w => nn.includes(w))) return n;
    }
    return null;
  }

  function pickFallbackSheet(wb){
    const names = wb?.SheetNames || [];
    return names.length ? names[0] : null;
  }

  // =========================================================
  // FILE HANDLING
  // =========================================================
  let lastCsvMatrix = null;
  let lastCsvName = "";

  async function handleFile(file){
    if(!file) return;

    lastCsvMatrix = null;
    lastCsvName = "";
    clearWizard();

    fileMeta.textContent = `Last file: ${file.name}`;
    showContractWarning("");

    const lower = norm(file.name);
    const isCsv = lower.endsWith(".csv");

    // -------------------------
    // CSV
    // -------------------------
    if(isCsv){
      setStatus("Reading CSV‚Ä¶");
      const text = await file.text();
      const rows = parseCsvToRows(text);
      lastCsvMatrix = rows;
      lastCsvName = file.name;

      previewRows(rows, `Preview CSV: ${file.name}`);

      stagedUpload = {
        type: "csv",
        fileName: file.name,
        rows
      };
      showCsvWizard(file.name);
      setStatus("CSV staged. Confirm destination in Import Wizard before saving.");
      return;
    }

    // -------------------------
    // Excel
    // -------------------------
    setStatus("Reading Excel‚Ä¶");
    const buf = await file.arrayBuffer();
    const wb = XLSX.read(buf, { type:"array" });
    const names = wb.SheetNames || [];

    // Tolerant picks
    const growSheet = pickSheetByName(wb, ["master grow","master_grow","grow","mg","01","1"]);
    const packSheet = pickSheetByName(wb, ["master pack","master_pack","pack","mp","04","4"]);
const expSheet  = pickSheetByName(wb, ["current experiments","experiments","experiment","exp"]);
const procSheet = pickSheetByName(wb, ["procurement","procure","purchasing","purchase","vendor","supplies"]);
const storeSheet = pickSheetByName(wb, ["store visit","store_visit","store","visit"]);

const plans = [];
    const toPlan = (kind, sheetName) => {
      if(!sheetName) return;
      const hr = sheetToHeaderRows(wb.Sheets[sheetName]);
      if(!isNonEmptySheet(hr)) return;
      plans.push({ kind, sheetName, hr, sourceLabel: `XLSX sheet: ${sheetName}` });
    };
    toPlan("grow", growSheet);
    toPlan("pack", packSheet);
    toPlan("exp", expSheet);
    toPlan("proc", procSheet);
    toPlan("store", storeSheet);

// Preview: whichever is present, otherwise first sheet
    const previewName = growSheet || packSheet || expSheet || procSheet || storeSheet || pickFallbackSheet(wb);
    if(previewName){
      const ws = wb.Sheets[previewName];
      const rows = XLSX.utils.sheet_to_json(ws, { header: 1, blankrows:false, raw:false });
      previewRows(rows, `Preview XLSX: ${previewName}`);
    } else {
      previewEl.innerHTML = `<div class="small" style="padding:10px;">No sheets found.</div>`;
    }

    if(!plans.length){
      setStatus("Excel loaded, but no recognized non-empty data sheets were found.");
      // Add a helpful warning about canonical keys
      showContractWarning(
        `Tip: Your dashboards require the canonical keys: sheets["${CANON_GROW_SHEET}"] and sheets["${CANON_PACK_SHEET}"]. ` +
        `This tool stages assignments only when it can identify supported sheets.`
      );
      return;
    }

    stagedUpload = {
      type: "xlsx",
      fileName: file.name,
      plans
    };
    showXlsxWizard(file.name, plans);
    setStatus("XLSX staged. Confirm Import Wizard assignments before saving.");
  }

  // =========================================================
  // DOWNLOAD JSON
  // =========================================================
  function downloadJsonFromLocalStorage(key, filename){
    const s = localStorage.getItem(key);
    if(!s) return setStatus(`Nothing stored for ${filename} yet.`);
    try { JSON.parse(s); } catch { return setStatus(`Stored JSON is invalid for ${filename}.`); }

    const blob = new Blob([s], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
    setStatus(`Downloaded ${filename}.`);
  }

  // =========================================================
  
function isObject(x){ return x && typeof x === "object" && !Array.isArray(x); }

function normalizeMasterPayload(raw, kind){
  // Ensures canonical sheet keys exist so dashboards never break.
  const want =
    (kind === "grow")  ? CANON_GROW_SHEET :
    (kind === "pack")  ? CANON_PACK_SHEET :
    (kind === "exp")   ? CANON_EXP_SHEET  :
    (kind === "proc")  ? CANON_PROC_SHEET :
    (kind === "store") ? CANON_STORE_SHEET :
    CANON_PROC_SHEET;

  if (!isObject(raw)) return raw;

  if (isObject(raw.sheets) && raw.sheets[want]) return raw;

  if (isObject(raw.sheets)) {
    const keys = Object.keys(raw.sheets);
    const wantLower = want.toLowerCase();

    let match = keys.find(k => String(k).trim().toLowerCase() === wantLower);
    if (!match && kind === "grow") match = keys.find(k => String(k).toLowerCase().includes("grow"));
    if (!match && kind === "pack") match = keys.find(k => String(k).toLowerCase().includes("pack"));
    if (!match && kind === "exp")  match = keys.find(k => String(k).toLowerCase().includes("experiment"));
    if (!match && kind === "proc") match = keys.find(k => String(k).toLowerCase().includes("procure"));
    if (!match && kind === "store") match = keys.find(k => String(k).toLowerCase().includes("store") || String(k).toLowerCase().includes("visit"));

    if (match) {
      const clone = JSON.parse(JSON.stringify(raw));
      clone.sheets = clone.sheets || {};
      clone.sheets[want] = clone.sheets[match];
      return clone;
    }
  }

  if (Array.isArray(raw.headers) && Array.isArray(raw.rows)) {
    return {
      version: raw.version || "v1",
      updatedAt: raw.updatedAt || new Date().toISOString(),
      kind: raw.kind || kind,
      sourceLabel: raw.sourceLabel || "worker",
      sheets: { [want]: { headers: raw.headers, rows: raw.rows } }
    };
  }

  return raw;
}

// WORKER HELPERS
  // =========================================================
  async function workerGetJson(url){
    const bust = url + (url.includes("?") ? "&" : "?") + "ts=" + Date.now();
    const res = await fetch(bust, { method:"GET", cache:"no-store" });
    const text = await res.text();
    if(!res.ok) throw new Error(text || `HTTP ${res.status}`);
    try { return JSON.parse(text); }
    catch { throw new Error("Worker returned non-JSON."); }
  }

  async function pullFromSupabase(){
  pullBtn.disabled = true;
  setStatus("Pulling from Supabase (via Worker)‚Ä¶");
  showContractWarning("");

  try { await fetch(WORKER_HEALTH_URL, { cache:"no-store" }); } catch {}

  try{
    let gotAny = false;
    const now = String(Date.now());

    try{
      const grow = normalizeMasterPayload(await workerGetJson(WORKER_GROW_URL), "grow");
      localStorage.setItem(MASTER_GROW_KEY, JSON.stringify(grow));
      localStorage.setItem(MASTER_GROW_PING, now);
      emit(MSG_GROW, MASTER_GROW_KEY);
      gotAny = true;
    }catch(e){ console.warn("Grow pull failed:", e); }

    try{
      const pack = normalizeMasterPayload(await workerGetJson(WORKER_PACK_URL), "pack");
      localStorage.setItem(MASTER_PACK_KEY, JSON.stringify(pack));
      localStorage.setItem(MASTER_PACK_PING, now);
      emit(MSG_PACK, MASTER_PACK_KEY);
      gotAny = true;
    }catch(e){ console.warn("Pack pull failed:", e); }

    try{
      const exp = normalizeMasterPayload(await workerGetJson(WORKER_EXP_URL), "exp");
      localStorage.setItem(MASTER_EXP_KEY, JSON.stringify(exp));
      localStorage.setItem(MASTER_EXP_PING, now);
      emit(MSG_EXP, MASTER_EXP_KEY);
      gotAny = true;
    }catch(e){ console.warn("Experiments pull failed:", e); }

    try{
      const proc = normalizeMasterPayload(await workerGetJson(WORKER_PROC_URL), "proc");
      localStorage.setItem(MASTER_PROC_KEY, JSON.stringify(proc));
      localStorage.setItem(MASTER_PROC_PING, now);
      emit(MSG_PROC, MASTER_PROC_KEY);
      gotAny = true;
    }catch(e){ console.warn("Procurement pull failed:", e); }

    try{
      const store = normalizeMasterPayload(await workerGetJson(WORKER_STORE_GET_URL), "store");
      localStorage.setItem(MASTER_STORE_KEY, JSON.stringify(store));
      localStorage.setItem(MASTER_STORE_PING, now);
      emit(MSG_STORE, MASTER_STORE_KEY);
      gotAny = true;
    }catch(e){ console.warn("Store Visit pull failed:", e); }

    refreshBadges();

    if(gotAny) setStatus("‚úÖ Pulled latest JSON into localStorage.");
    else setStatus("‚ö†Ô∏è Nothing pulled. (Worker returned errors / files missing.)");

    const v = validateStorageContract();
    if (!v.ok) showContractWarning(v.msg);
  }catch(err){
    console.error(err);
    setStatus(`‚ùå Pull failed: ${err.message}`);
  }finally{
    pullBtn.disabled = false;
  }
}

async function publishToSupabase(){
    const growStr = localStorage.getItem(MASTER_GROW_KEY);
    const packStr = localStorage.getItem(MASTER_PACK_KEY);
    const expStr  = localStorage.getItem(MASTER_EXP_KEY);
    const procStr = localStorage.getItem(MASTER_PROC_KEY);
    const storeStr = localStorage.getItem(MASTER_STORE_KEY);

    if(!growStr && !packStr && !expStr && !procStr && !storeStr){
      setStatus("Nothing to publish (Grow / Pack / Exp / Procurement / Store Visit).");
      return;
    }

    // validate JSON early
    try { if(growStr) JSON.parse(growStr); } catch { return setStatus("Grow JSON is invalid (cannot publish)."); }
    try { if(packStr) JSON.parse(packStr); } catch { return setStatus("Pack JSON is invalid (cannot publish)."); }
    try { if(expStr)  JSON.parse(expStr);  } catch { return setStatus("Experiments JSON is invalid (cannot publish)."); }
    try { if(procStr) JSON.parse(procStr); } catch { return setStatus("Procurement JSON is invalid (cannot publish)."); }
    try { if(storeStr) JSON.parse(storeStr); } catch { return setStatus("Store Visit JSON is invalid (cannot publish)."); }

    // Contract check (warn but allow publish if you want)
    const v = validateStorageContract();
    if (!v.ok) showContractWarning(v.msg);

    publishBtn.disabled = true;
    setStatus("Publishing to Supabase (via Worker PUT /data/...)‚Ä¶");

    try{
      const results = [];

      if(growStr){
        const res = await fetch(WORKER_GROW_URL, {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: growStr
        });
        const text = await res.text().catch(() => "");
        if(!res.ok) throw new Error(`Grow publish failed (${res.status}): ${text}`);
        results.push("grow.json");
      }

      if(packStr){
        const res = await fetch(WORKER_PACK_URL, {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: packStr
        });
        const text = await res.text().catch(() => "");
        if(!res.ok) throw new Error(`Pack publish failed (${res.status}): ${text}`);
        results.push("pack.json");
      }

      if(expStr){
        const res = await fetch(WORKER_EXP_URL, {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: expStr
        });
        const text = await res.text().catch(() => "");
        if(!res.ok) throw new Error(`Experiments publish failed (${res.status}): ${text}`);
        results.push("experiments.json");
      }

      if(procStr){
        const res = await fetch(WORKER_PROC_URL, {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: procStr
        });
        const text = await res.text().catch(() => "");
        if(!res.ok) throw new Error(`Procurement publish failed (${res.status}): ${text}`);
        results.push("procurement.json");
      }

      if(storeStr){
        const res = await fetch(WORKER_STORE_URL, {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: storeStr
        });
        const text = await res.text().catch(() => "");
        if(!res.ok) throw new Error(`Store Visit publish failed (${res.status}): ${text}`);
        results.push("Store Visits.json");
      }

      setStatus(`‚úÖ Published: ${results.join(" + ")}`);
    }catch(err){
      console.error(err);
      setStatus(`‚ùå Publish failed: ${err.message}`);
    }finally{
      publishBtn.disabled = false;
      refreshBadges();
    }
  }

  // =========================================================
  // WIRE EVENTS
  // =========================================================
  chooseBtn.addEventListener("click", () => fileInput.click());
  fileInput.addEventListener("change", (e) => handleFile(e.target.files?.[0] || null));

  wizConfirmCsvBtn.addEventListener("click", () => {
    if(!stagedUpload || stagedUpload.type !== "csv"){
      setStatus("No staged CSV upload to confirm.");
      return;
    }
    const target = wizTarget.value;
    if(!target){
      setStatus("Pick a destination dataset before confirming.");
      return;
    }
    const hr = rowsToHeaderRows(stagedUpload.rows || []);
    const sourceLabel = `CSV: ${stagedUpload.fileName}`;
    if(target === "grow") saveSource("grow", buildPayloadSingleCanonical(CANON_GROW_SHEET, hr, { kind: "grow", sourceLabel }), sourceLabel);
    else if(target === "pack") saveSource("pack", buildPayloadSingleCanonical(CANON_PACK_SHEET, hr, { kind: "pack", sourceLabel }), sourceLabel);
    else if(target === "exp") saveSource("exp", buildPayloadSingleCanonical(CANON_EXP_SHEET, hr, { kind: "exp", sourceLabel }), sourceLabel);
    else if(target === "proc") saveSource("proc", buildPayloadSingleCanonical(CANON_PROC_SHEET, hr, { kind: "proc", sourceLabel }), sourceLabel);
    else if(target === "store") saveSource("store", buildPayloadSingleCanonical(CANON_STORE_SHEET, hr, { kind: "store", sourceLabel }), sourceLabel);
    clearWizard();
    setStatus(`CSV confirmed and assigned to ${KIND_LABEL[target]}.`);
  });

  wizConfirmXlsxBtn.addEventListener("click", () => {
    if(!stagedUpload || stagedUpload.type !== "xlsx"){
      setStatus("No staged XLSX upload to confirm.");
      return;
    }
    const plans = stagedUpload.plans || [];
    if(!plans.length){
      setStatus("No staged XLSX assignments found.");
      return;
    }
    const selects = Array.from(wizXlsxList.querySelectorAll("select[data-plan-index]"));
    for(let i=0; i<plans.length; i++){
      const p = plans[i];
      const sel = selects.find(s => Number(s.getAttribute("data-plan-index")) === i);
      const target = sel ? sel.value : p.kind;
      const canonical =
        target === "grow" ? CANON_GROW_SHEET :
        target === "pack" ? CANON_PACK_SHEET :
        target === "exp" ? CANON_EXP_SHEET :
        target === "proc" ? CANON_PROC_SHEET :
        CANON_STORE_SHEET;
      const payload = buildPayloadSingleCanonical(canonical, p.hr, { kind: target, sourceLabel: p.sourceLabel });
      saveSource(target, payload, p.sourceLabel);
    }
    clearWizard();
    const chosen = selects.map(s => KIND_LABEL[s.value] || s.value);
    setStatus(`XLSX confirmed and assigned: ${chosen.join(", ")}.`);
  });

  wizCancelBtn.addEventListener("click", () => {
    clearWizard();
    setStatus("Staged upload cancelled.");
  });
  wizCancelBtn2.addEventListener("click", () => {
    clearWizard();
    setStatus("Staged upload cancelled.");
  });

  clearBtn.addEventListener("click", () => {
    lastCsvMatrix = null;
    lastCsvName = "";
    try{
      localStorage.removeItem(MASTER_GROW_KEY);
  localStorage.removeItem(MASTER_PACK_KEY);
  localStorage.removeItem(MASTER_EXP_KEY);
  localStorage.removeItem(MASTER_PROC_KEY);
  localStorage.removeItem(MASTER_STORE_KEY);
  localStorage.removeItem(MASTER_GROW_PING);
  localStorage.removeItem(MASTER_PACK_PING);
  localStorage.removeItem(MASTER_EXP_PING);
  localStorage.removeItem(MASTER_PROC_PING);
  localStorage.removeItem(MASTER_STORE_PING);
  localStorage.removeItem(LAST_ASSIGN_META_KEY);
    }catch(e){}

    emit(MSG_GROW, MASTER_GROW_KEY);
    emit(MSG_PACK, MASTER_PACK_KEY);
    emit(MSG_EXP, MASTER_EXP_KEY);
    emit(MSG_PROC, MASTER_PROC_KEY);
    emit(MSG_STORE, MASTER_STORE_KEY);

    previewEl.innerHTML = `<div class="small" style="padding:10px;">Upload a file to preview data.</div>`;
    clearWizard();
    setStatus("Cleared stored sources.");
    showContractWarning("");
    refreshBadges();
  });

  growDlBtn.addEventListener("click", () => downloadJsonFromLocalStorage(MASTER_GROW_KEY, "grow.json"));
  packDlBtn.addEventListener("click", () => downloadJsonFromLocalStorage(MASTER_PACK_KEY, "pack.json"));
  expDlBtn.addEventListener("click", () => downloadJsonFromLocalStorage(MASTER_EXP_KEY, "experiments.json"));
  procDlBtn.addEventListener("click", () => downloadJsonFromLocalStorage(MASTER_PROC_KEY, "procurement.json"));
  storeDlBtn.addEventListener("click", () => downloadJsonFromLocalStorage(MASTER_STORE_KEY, "store-visit.json"));

  publishBtn.addEventListener("click", publishToSupabase);
  pullBtn.addEventListener("click", pullFromSupabase);

  // Drag & drop
  ["dragenter","dragover"].forEach(evt => {
    dropzone.addEventListener(evt, (e) => {
      e.preventDefault(); e.stopPropagation();
      dropzone.classList.add("dragover");
    });
  });
  ["dragleave","drop"].forEach(evt => {
    dropzone.addEventListener(evt, (e) => {
      e.preventDefault(); e.stopPropagation();
      dropzone.classList.remove("dragover");
    });
  });
  dropzone.addEventListener("drop", (e) => {
    const file = e.dataTransfer?.files?.[0];
    handleFile(file || null);
  });

  // Keep badges fresh if something else updates localStorage
  window.addEventListener("storage", (e) => {
    if (!e) return;
    if ([MASTER_GROW_KEY, MASTER_PACK_KEY, MASTER_EXP_KEY, MASTER_PROC_KEY, MASTER_STORE_KEY, MASTER_GROW_PING, MASTER_PACK_PING, MASTER_EXP_PING, MASTER_PROC_PING, MASTER_STORE_PING, LAST_ASSIGN_META_KEY].includes(e.key)) {
      refreshBadges();
    }
  });

  // =========================================================
  // INIT
  // =========================================================
  refreshBadges();
  setStatus("Waiting for file‚Ä¶");
</script>
</body>
</html>
